{"id":"attractor-01g","title":"Implement AST transforms and variable expansion","description":"# AST Transforms (attractor-pipeline)\n\n## What\nImplement the transform pipeline from attractor-spec.md Section 9.\n\n## Transform trait\n```rust\npub trait Transform: Send + Sync {\n    fn apply(\u0026self, graph: PipelineGraph) -\u003e Result\u003cPipelineGraph, AttractorError\u003e;\n}\n```\n\nTransforms applied after parsing, before validation:\n```\ngraph = parse(dot_source)\nfor transform in transforms:\n    graph = transform.apply(graph)\ndiagnostics = validate(graph)\n```\n\n## Built-in transforms\n\n### VariableExpansionTransform\nReplace $goal in node prompt attributes with graph-level goal value.\nSimple string replacement, not a templating engine.\n\n### StylesheetApplicationTransform\nApply model_stylesheet to resolve llm_model, llm_provider, reasoning_effort per node.\n(Depends on stylesheet parser from previous task.)\n\n### PreambleTransform (runtime)\nSynthesize context carryover text for non-full fidelity nodes.\nApplied at execution time since it depends on runtime state.\n\n## Custom transforms\nRegistered via runner.register_transform(MyTransform::new()).\nRun after built-in transforms in registration order.\n\n## Acceptance criteria\n- Transform trait is implementable\n- Variable expansion replaces $goal correctly\n- Stylesheet transform applies model overrides\n- Transforms run in correct order (built-in first, then custom)\n- Custom transforms can modify graph structure","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:25:43.763077-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:25:43.763077-08:00","dependencies":[{"issue_id":"attractor-01g","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:11.197388-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-01g","depends_on_id":"attractor-oeg","type":"blocks","created_at":"2026-02-10T14:27:11.528328-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-0t4","title":"Implement built-in tools (read_file, write_file, edit_file, shell, grep, glob)","description":"# Built-in Tools (attractor-tools)\n\n## What\nImplement the 6 core tools that all provider profiles share, per agent-loop spec Section 3.3.\n\n## Tools\n\n### read_file\n- Reads file with line numbers in \"NNN | content\" format\n- Parameters: file_path (required), offset (optional, 1-based), limit (optional, default 2000)\n- For images: return image data for multimodal models\n\n### write_file\n- Creates file and parent directories if needed\n- Parameters: file_path (required), content (required)\n- Returns confirmation with bytes written\n\n### edit_file (Anthropic-native format)\n- Exact string search and replace\n- Parameters: file_path, old_string, new_string, replace_all (optional, default false)\n- If old_string not unique and replace_all=false: return error\n- May attempt fuzzy matching (whitespace normalization) if exact match fails\n\n### shell\n- Execute command via ExecutionEnvironment\n- Parameters: command (required), timeout_ms (optional), description (optional)\n- Default timeout: 10s (from SessionConfig)\n- Returns stdout+stderr, exit code, duration\n- On timeout: include message telling model to retry with longer timeout\n\n### grep\n- Search file contents by regex pattern\n- Parameters: pattern, path (optional), glob_filter (optional), case_insensitive, max_results\n- Delegates to ExecutionEnvironment.grep()\n\n### glob\n- Find files by pattern\n- Parameters: pattern (required), path (optional)\n- Returns paths sorted by modification time (newest first)\n\n## Output truncation (spec Section 5)\nEach tool output passes through truncation before reaching the LLM:\n| Tool | Max Chars | Mode |\n|------|-----------|------|\n| read_file | 50,000 | head_tail |\n| shell | 30,000 | head_tail |\n| grep | 20,000 | tail |\n| glob | 20,000 | tail |\n| edit_file | 10,000 | tail |\n| write_file | 1,000 | tail |\n\nTruncation inserts visible marker:\n[WARNING: Tool output was truncated. N characters were removed...]\n\n## Acceptance criteria\n- All 6 tools implement Tool trait correctly\n- read_file adds line numbers and respects offset/limit\n- edit_file finds and replaces exact strings\n- shell respects timeout and returns structured output\n- Output truncation works with head_tail and tail modes\n- Truncation marker is clear and informative\n- All tools work through the ExecutionEnvironment abstraction","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:18:23.863695-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:18:23.863695-08:00","dependencies":[{"issue_id":"attractor-0t4","depends_on_id":"attractor-vsf","type":"blocks","created_at":"2026-02-10T14:26:59.480099-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-0t4","depends_on_id":"attractor-8qq","type":"blocks","created_at":"2026-02-10T14:26:59.788416-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-28l","title":"Implement Context (thread-safe key-value store)","description":"# Context: Thread-Safe Key-Value Store (attractor-types)\n\n## What\nImplement the Context type — the primary mechanism for passing data between pipeline nodes.\nDefined in attractor-spec.md Section 5.1.\n\n## Why\nContext is used everywhere:\n- Handlers read context to get graph.goal, last_stage, last_response\n- Handlers return context_updates in Outcome, which the engine merges\n- Edge conditions evaluate against context values\n- Checkpoint serializes context for crash recovery\n- Parallel branches clone context for isolation\n\n## Design\n\nUse `Arc\u003ctokio::sync::RwLock\u003cContextInner\u003e\u003e` for async-safe concurrent access.\ntokio RwLock (not std) because context reads happen inside async handlers.\n\n```rust\n#[derive(Clone)]\npub struct Context {\n    inner: Arc\u003ctokio::sync::RwLock\u003cContextInner\u003e\u003e,\n}\n\nstruct ContextInner {\n    values: HashMap\u003cString, serde_json::Value\u003e,\n    logs: Vec\u003cString\u003e,\n}\n```\n\n## Methods (from spec Section 5.1)\n- `set(key, value)` — write lock, insert\n- `get(key) -\u003e Option\u003cValue\u003e` — read lock, lookup\n- `get_string(key, default) -\u003e String` — convenience\n- `append_log(entry)` — write lock, append to log\n- `snapshot() -\u003e HashMap` — read lock, shallow copy for serialization\n- `clone_isolated() -\u003e Context` — deep copy for parallel branch isolation\n- `apply_updates(HashMap)` — write lock, merge batch of updates\n\n## Built-in context keys (set by engine)\n| Key | Set By | Description |\n|-----|--------|-------------|\n| outcome | Engine | Last handler outcome status |\n| preferred_label | Engine | Last handler's preferred edge label |\n| graph.goal | Engine | Mirrored from graph goal attribute |\n| current_node | Engine | ID of currently executing node |\n| last_stage | Handler | ID of last completed stage |\n| last_response | Handler | Truncated last LLM response |\n| internal.retry_count.\u003cnode_id\u003e | Engine | Per-node retry counter |\n\n## Acceptance criteria\n- Thread safety: concurrent reads don't block each other\n- clone_isolated creates an independent copy (mutations don't cross)\n- snapshot serializes to JSON correctly\n- apply_updates merges without losing existing keys\n- Tests with tokio::spawn verify concurrent access works","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:15:41.461392-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:15:41.461392-08:00","dependencies":[{"issue_id":"attractor-28l","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:53.328702-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-28l","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:26:54.607716-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-376","title":"Implement provider-aligned tool profiles (OpenAI, Anthropic, Gemini)","description":"# Provider-Aligned Tool Profiles (attractor-tools / attractor-agent)\n\n## What\nCreate provider-specific tool profiles that bundle the correct tools and system prompts\nfor each LLM provider, per agent-loop spec Section 3.\n\n## Why (The Provider Alignment Principle - spec Section 3.1)\nModels are trained on specific tool formats. Using a provider's native format produces\nbetter results. The initial base should be a 1:1 copy of the provider's reference agent.\n\n## Profiles\n\n### Anthropic Profile (Claude Code-aligned)\n- Tools: read_file, write_file, edit_file (old_string/new_string - native format), shell (120s default timeout), grep, glob\n- System prompt mirrors Claude Code style: identity, tool selection guidance, edit format explanation\n- DO NOT use apply_patch with Anthropic models\n\n### OpenAI Profile (codex-rs-aligned)\n- Tools: read_file, apply_patch (v4a format - replaces edit_file), write_file, shell (10s default timeout), grep, glob\n- apply_patch is the key difference — OpenAI models are trained on this format\n- System prompt mirrors codex-rs style\n\n### Gemini Profile (gemini-cli-aligned)\n- Tools: read_file, read_many_files, write_file, edit_file, shell (10s default timeout), grep, glob, list_dir\n- Optional: web_search, web_fetch\n- System prompt mirrors gemini-cli style\n\n## ProviderProfile struct\n\\`\\`\\`rust\npub struct ProviderProfile {\n    pub id: String,               // \"openai\", \"anthropic\", \"gemini\"\n    pub model: String,\n    pub tool_registry: ToolRegistry,\n    pub supports_parallel_tool_calls: bool,\n    pub supports_reasoning: bool,\n    pub supports_streaming: bool,\n    pub context_window_size: usize,\n}\n\nimpl ProviderProfile {\n    pub fn anthropic(model: \u0026str) -\u003e Self;\n    pub fn openai(model: \u0026str) -\u003e Self;\n    pub fn gemini(model: \u0026str) -\u003e Self;\n    pub fn build_system_prompt(\u0026self, env: \u0026dyn ExecutionEnvironment, project_docs: \u0026str) -\u003e String;\n    pub fn tools(\u0026self) -\u003e Vec\u003cToolDefinition\u003e;\n}\n\\`\\`\\`\n\n## Acceptance criteria\n- Each profile provides the correct tool set for its provider\n- System prompts cover: identity, tool usage, editing format, coding guidance\n- Custom tools can be added on top of any profile\n- Tool name collisions: latest-wins","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:18:40.210322-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:18:40.210322-08:00","dependencies":[{"issue_id":"attractor-376","depends_on_id":"attractor-vsf","type":"blocks","created_at":"2026-02-10T14:27:00.132714-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-376","depends_on_id":"attractor-0t4","type":"blocks","created_at":"2026-02-10T14:27:00.452884-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-3zy","title":"Implement ProviderAdapter trait and DynProvider wrapper","description":"# ProviderAdapter Trait (attractor-llm)\n\n## What\nDefine the core trait that all LLM provider adapters implement, plus the DynProvider\nwrapper that makes it object-safe for storage in HashMap\u003cString, Box\u003cdyn\u003e\u003e.\n\n## Why\nThis is the central abstraction of the LLM layer. Every provider (OpenAI, Anthropic,\nGemini) implements this trait. The LlmClient stores providers as trait objects.\n\n## The object-safety challenge\nRust native async fn in traits (stable since 1.75) does NOT support dyn Trait.\nWe need providers stored as Box\u003cdyn ProviderAdapter\u003e in a HashMap.\n\nSolution: manual boxing wrapper pattern.\n\n```rust\n// The nice trait that provider implementors use\npub trait ProviderAdapter: Send + Sync {\n    async fn complete(\u0026self, request: \u0026Request) -\u003e Result\u003cResponse, AttractorError\u003e;\n    fn stream(\u0026self, request: \u0026Request) -\u003e Pin\u003cBox\u003cdyn Stream\u003cItem = StreamEvent\u003e + Send + '_\u003e\u003e;\n    fn name(\u0026self) -\u003e \u0026str;\n    fn default_model(\u0026self) -\u003e \u0026str;\n    fn supports_tools(\u0026self) -\u003e bool;\n    fn supports_streaming(\u0026self) -\u003e bool;\n    fn supports_reasoning(\u0026self) -\u003e bool;\n    fn context_window_size(\u0026self) -\u003e usize;\n}\n\n// Object-safe version (internal)\ntrait ProviderAdapterDyn: Send + Sync {\n    fn complete_dyn(\u0026self, request: \u0026Request)\n        -\u003e Pin\u003cBox\u003cdyn Future\u003cOutput = Result\u003cResponse, AttractorError\u003e\u003e + Send + '_\u003e\u003e;\n    fn stream_dyn(\u0026self, request: \u0026Request)\n        -\u003e Pin\u003cBox\u003cdyn Stream\u003cItem = StreamEvent\u003e + Send + '_\u003e\u003e;\n    fn name(\u0026self) -\u003e \u0026str;\n    fn default_model(\u0026self) -\u003e \u0026str;\n    fn supports_tools(\u0026self) -\u003e bool;\n    fn supports_streaming(\u0026self) -\u003e bool;\n    fn supports_reasoning(\u0026self) -\u003e bool;\n    fn context_window_size(\u0026self) -\u003e usize;\n}\n\n// Blanket impl\nimpl\u003cT: ProviderAdapter\u003e ProviderAdapterDyn for T { ... }\n\n// Public wrapper\npub struct DynProvider(Box\u003cdyn ProviderAdapterDyn\u003e);\n\nimpl DynProvider {\n    pub fn new(provider: impl ProviderAdapter + 'static) -\u003e Self { ... }\n    pub async fn complete(\u0026self, request: \u0026Request) -\u003e Result\u003cResponse, AttractorError\u003e { ... }\n    pub fn stream(\u0026self, request: \u0026Request) -\u003e Pin\u003cBox\u003cdyn Stream\u003cItem = StreamEvent\u003e + Send + '_\u003e\u003e { ... }\n}\n```\n\n## Acceptance criteria\n- ProviderAdapter can be implemented with normal async fn\n- DynProvider wraps any ProviderAdapter into an object-safe type\n- DynProvider can be stored in HashMap\u003cString, DynProvider\u003e\n- complete() and stream() work through the wrapper\n- All capability query methods (supports_tools, etc.) pass through","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:16:37.522523-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:16:37.522523-08:00","dependencies":[{"issue_id":"attractor-3zy","depends_on_id":"attractor-eg6","type":"blocks","created_at":"2026-02-10T14:26:56.569504-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-4ac","title":"Implement DOT parser for strict Graphviz subset","description":"# DOT Parser (attractor-dot)\n\n## What\nHand-rolled recursive descent parser using winnow for the strict DOT subset defined\nin attractor-spec.md Section 2.\n\n## Why hand-rolled (not using existing crate)\n- Spec defines a STRICT SUBSET — existing crates parse full Graphviz and carry unnecessary\n  complexity (HTML labels, undirected graphs, etc.)\n- Need TYPED ATTRIBUTES — shape determines handler type, condition on edges needs validation\n- Existing crates (dot-parser, graphviz-rust) are low-download-count, varying maintenance\n- The subset grammar is ~15-20 production rules — manageable\n- winnow gives excellent error messages with span tracking (critical for user-facing errors)\n\n## Grammar (spec Section 2.2)\n```\nGraph           ::= 'digraph' Identifier '{' Statement* '}'\nStatement       ::= GraphAttrStmt | NodeDefaults | EdgeDefaults | SubgraphStmt\n                   | NodeStmt | EdgeStmt | GraphAttrDecl\nGraphAttrStmt   ::= 'graph' AttrBlock ';'?\nNodeDefaults    ::= 'node' AttrBlock ';'?\nEdgeDefaults    ::= 'edge' AttrBlock ';'?\nSubgraphStmt    ::= 'subgraph' Identifier? '{' Statement* '}'\nNodeStmt        ::= Identifier AttrBlock? ';'?\nEdgeStmt        ::= Identifier ( '-\u003e' Identifier )+ AttrBlock? ';'?\nAttrBlock       ::= '[' Attr ( ',' Attr )* ']'\nAttr            ::= Key '=' Value\nValue           ::= String | Integer | Float | Boolean | Duration\nIdentifier      ::= [A-Za-z_][A-Za-z0-9_]*\n```\n\n## Key constraints to enforce\n- One digraph per file (reject multiple graphs, undirected, strict modifier)\n- Directed edges only (-\u003e only, reject --)\n- Commas required between attributes\n- Comments stripped (// line and /* block */)\n- Semicolons optional\n\n## Value types\n| Type | Syntax | Examples |\n|------|--------|----------|\n| String | Double-quoted with escapes | \"Hello world\", \"line1\\nline2\" |\n| Integer | Optional sign + digits | 42, -1, 0 |\n| Float | Decimal number | 0.5, -3.14 |\n| Boolean | Literal keywords | true, false |\n| Duration | Integer + unit suffix | 900s, 15m, 2h, 250ms, 1d |\n\n## AST types\n```rust\npub struct DotGraph {\n    pub name: String,\n    pub attrs: HashMap\u003cString, AttributeValue\u003e,\n    pub nodes: HashMap\u003cString, NodeDef\u003e,\n    pub edges: Vec\u003cEdgeDef\u003e,\n    pub subgraphs: Vec\u003cSubgraphDef\u003e,\n    pub node_defaults: HashMap\u003cString, AttributeValue\u003e,\n    pub edge_defaults: HashMap\u003cString, AttributeValue\u003e,\n}\n\npub struct NodeDef {\n    pub id: String,\n    pub attrs: HashMap\u003cString, AttributeValue\u003e,\n}\n\npub struct EdgeDef {\n    pub from: String,\n    pub to: String,\n    pub attrs: HashMap\u003cString, AttributeValue\u003e,\n}\n\npub enum AttributeValue {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    Duration(Duration),\n}\n```\n\n## Chained edge expansion (spec Section 2.9)\nA -\u003e B -\u003e C [label=\"next\"] expands to:\n  A -\u003e B [label=\"next\"]\n  B -\u003e C [label=\"next\"]\n\n## Subgraph handling (spec Section 2.10)\n- Scoping defaults: node [...] in subgraph applies to nodes within\n- Class derivation: subgraph label \"Loop A\" → derived class \"loop-a\"\n- Nodes inherit from innermost enclosing subgraph defaults\n\n## Error reporting\nParse errors must include:\n- Line and column number\n- Source snippet showing the error location\n- Expected token/pattern description\n\n## Acceptance criteria\n- Parses all 3 example DOT files from spec Section 2.13 (linear, branching, human gate)\n- Parses the integration smoke test DOT from spec Section 11.13\n- Rejects: undirected graphs, multiple graphs, -- edges\n- Chained edges expanded correctly\n- Subgraph defaults applied to contained nodes\n- Comments stripped without affecting parsing\n- Duration values parsed (900s, 15m, etc.)\n- Multi-line attribute blocks work\n- Error messages include line/col and are human-readable\n- Property tests with proptest for parser robustness","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:16:21.891465-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:16:21.891465-08:00","dependencies":[{"issue_id":"attractor-4ac","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:53.958666-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-4l7","title":"Write comprehensive integration test suite","description":"# Integration Test Suite\n\n## What\nEnd-to-end tests that verify the full pipeline works correctly, covering the\ncross-feature parity matrix from attractor-spec.md Section 11.12.\n\n## Test fixtures\ntests/fixtures/pipelines/:\n- simple_linear.dot — start → A → B → exit\n- conditional_branch.dot — success/fail paths\n- human_gate.dot — hexagon node with choices\n- parallel_fanout.dot — component node with branches\n- goal_gate.dot — goal_gate=true node blocking exit\n- retry_loop.dot — node with max_retries=2\n- stylesheet.dot — model_stylesheet with selectors\n- smoke_test.dot — the full integration test from spec Section 11.13\n\n## Test matrix (spec Section 11.12)\n| Test Case | Pass |\n|-----------|------|\n| Parse simple linear pipeline | [ ] |\n| Parse pipeline with graph-level attributes | [ ] |\n| Parse multi-line node attributes | [ ] |\n| Validate: missing start node → error | [ ] |\n| Validate: missing exit node → error | [ ] |\n| Validate: orphan node → warning | [ ] |\n| Execute linear 3-node pipeline end-to-end | [ ] |\n| Execute with conditional branching | [ ] |\n| Execute with retry on failure (max_retries=2) | [ ] |\n| Goal gate blocks exit when unsatisfied | [ ] |\n| Goal gate allows exit when all satisfied | [ ] |\n| Wait.human presents choices | [ ] |\n| Edge selection: condition match wins over weight | [ ] |\n| Edge selection: weight breaks ties | [ ] |\n| Edge selection: lexical tiebreak | [ ] |\n| Context updates visible to next node | [ ] |\n| Checkpoint save and resume | [ ] |\n| Stylesheet applies model override | [ ] |\n| Prompt variable expansion ($goal) | [ ] |\n| Parallel fan-out and fan-in | [ ] |\n| Custom handler registration | [ ] |\n| Pipeline with 10+ nodes completes | [ ] |\n\n## Test infrastructure\n- SimulationBackend for LLM responses (no API keys needed)\n- TestHarness struct: mock providers + temp dir + executor\n- wiremock for HTTP-level LLM provider tests\n\n## Acceptance criteria\n- All 22 test cases pass\n- Tests run without API keys (simulation backend)\n- Test fixtures checked into repo\n- cargo test --workspace passes cleanly","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:51.329335-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:51.329335-08:00","dependencies":[{"issue_id":"attractor-4l7","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:14.460353-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-4l7","depends_on_id":"attractor-c0i","type":"blocks","created_at":"2026-02-10T14:27:14.789541-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-4l7","depends_on_id":"attractor-etr","type":"blocks","created_at":"2026-02-10T14:27:15.109421-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-4lf","title":"Implement LlmClient with middleware chain and model catalog","description":"# LlmClient: Core Client Layer (attractor-llm)\n\n## What\nThe main orchestration layer (spec Section 2.2-2.5). Routes requests to the correct\nprovider adapter, applies middleware, manages configuration.\n\n## Design\n```rust\npub struct LlmClient {\n    providers: HashMap\u003cString, DynProvider\u003e,\n    default_provider: Option\u003cString\u003e,\n    middleware: Vec\u003cBox\u003cdyn Middleware\u003e\u003e,\n    model_catalog: ModelCatalog,\n}\n```\n\n## Key methods\n- from_env() — read OPENAI_API_KEY, ANTHROPIC_API_KEY, GEMINI_API_KEY from env,\n  register providers that have keys present\n- complete(request) → route to provider, apply middleware chain, return response\n- stream(request) → route to provider, stream events through middleware\n- register_provider(name, adapter) — add or replace a provider\n- set_default_provider(name)\n\n## Provider resolution (spec Section 2.2)\n1. Request specifies provider field → use that adapter\n2. No provider field → use default_provider\n3. No default → raise configuration error\n\n## Middleware (spec Section 2.3)\nOnion/chain pattern: first registered = first for request, last for response.\n```rust\npub trait Middleware: Send + Sync {\n    async fn process(\u0026self, request: Request, next: MiddlewareNext\u003c'_\u003e) -\u003e Result\u003cResponse\u003e;\n}\n```\nBuilt-in middleware: LoggingMiddleware (tracing), UsageTrackingMiddleware (aggregate tokens)\n\n## Model Catalog (spec Section 2.9)\nKnown models with metadata (context window, capabilities, costs).\nget_model_info(id), list_models(provider), get_latest_model(provider, capability)\nShip with current models: Claude Opus 4.6, Sonnet 4.5, GPT-5.2, Gemini 3 Flash, etc.\n\n## Acceptance criteria\n- from_env() registers available providers\n- Requests route to correct provider\n- Middleware chain executes in correct order\n- Model catalog provides accurate info\n- Unknown provider → clear error\n- Thread-safe (Send + Sync)","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:17:28.05787-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:17:28.05787-08:00","dependencies":[{"issue_id":"attractor-4lf","depends_on_id":"attractor-3zy","type":"blocks","created_at":"2026-02-10T14:26:57.881601-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-4lf","depends_on_id":"attractor-tea","type":"blocks","created_at":"2026-02-10T14:26:58.224277-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-4y0","title":"Implement optional HTTP server mode (axum)","description":"# HTTP Server Mode (attractor-pipeline / attractor-server)\n\n## What\nOptional axum-based HTTP server from attractor-spec.md Section 9.5.\n\n## Endpoints\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /pipelines | Submit DOT source, start execution |\n| GET | /pipelines/{id} | Get status and progress |\n| GET | /pipelines/{id}/events | SSE stream of events |\n| POST | /pipelines/{id}/cancel | Cancel running pipeline |\n| GET | /pipelines/{id}/graph | Rendered graph (SVG) |\n| GET | /pipelines/{id}/questions | Pending human questions |\n| POST | /pipelines/{id}/questions/{qid}/answer | Submit answer |\n| GET | /pipelines/{id}/checkpoint | Current checkpoint |\n| GET | /pipelines/{id}/context | Current context |\n\n## Feature-gated behind http-server feature flag.\nLower priority — implement after CLI works.\n\n## Acceptance criteria\n- POST /pipelines starts pipeline and returns ID\n- GET /pipelines/{id}/events streams SSE events\n- Human gates operable via web POST\n- Pipeline cancellation works","status":"open","priority":4,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:08.337759-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:08.337759-08:00","dependencies":[{"issue_id":"attractor-4y0","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:15.427581-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-4y0","depends_on_id":"attractor-pj2","type":"blocks","created_at":"2026-02-10T14:27:15.732331-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-4y0","depends_on_id":"attractor-hrl","type":"blocks","created_at":"2026-02-10T14:27:16.124693-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-6p2","title":"Implement subagent spawning and management","description":"# Subagent System (attractor-agent)\n\n## What\nImplement the subagent tools (spawn_agent, send_input, wait, close_agent) that allow\nthe parent agent to delegate scoped tasks to child sessions.\n\n## Design\n- Each subagent gets its own AgentSession with independent history\n- Shares parent's ExecutionEnvironment (same filesystem)\n- Uses parent's ProviderProfile (or overridden model)\n- Has own turn limits (default: 50)\n- Depth limiting: max_subagent_depth (default: 1, no sub-sub-agents)\n- Spawned via tokio::task::spawn\n\n## Tools (spec Section 7.2)\n- spawn_agent: create child session, return agent_id\n- send_input: queue message to running subagent\n- wait: block until subagent completes, return result\n- close_agent: terminate subagent\n\n## Acceptance criteria\n- Subagent runs independently with own conversation\n- Shares parent filesystem\n- Depth limiting prevents recursive spawning\n- Results returned to parent as tool results\n- close_agent terminates running subagent cleanly","status":"open","priority":3,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:19:19.855717-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:19:19.855717-08:00","dependencies":[{"issue_id":"attractor-6p2","depends_on_id":"attractor-mq9","type":"blocks","created_at":"2026-02-10T14:27:02.107043-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-8ki","title":"Implement Gemini provider adapter (native API)","description":"# Gemini Provider Adapter (attractor-llm)\n\n## What\nImplement Gemini adapter using native API (/v1beta/models/*/generateContent).\n\n## Why native API\nThe native Gemini API supports grounding with Google Search, code execution,\nsystem instructions, and cached content. OpenAI-compatible endpoints are limited shims.\n\n## Request/Response translation\n- System messages → systemInstruction field\n- User → user role, Assistant → model role\n- Tool results → functionResponse in user message\n- Tools → functionDeclarations\n\n## Streaming\nGemini streams via SSE from the streamGenerateContent endpoint.\n\n## Prompt caching\nAutomatic prefix caching. Expose explicit caching via provider_options for long contexts.\n\n## Acceptance criteria\n- complete() and stream() work with Gemini API\n- System instructions handled correctly\n- Tool calling works\n- Safety settings passable via provider_options","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:17:13.487254-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:17:13.487254-08:00","dependencies":[{"issue_id":"attractor-8ki","depends_on_id":"attractor-3zy","type":"blocks","created_at":"2026-02-10T14:26:57.544085-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-8qq","title":"Implement LocalExecutionEnvironment","description":"# LocalExecutionEnvironment (attractor-tools)\n\n## What\nDefault execution environment that runs everything on the local machine.\nRequired implementation per agent-loop spec Section 4.2.\n\n## File operations\nDirect filesystem access. Paths resolved relative to working_directory().\n\n## Command execution\n- Spawn in new process group for clean killability (setsid on Linux, setpgid)\n- Use platform shell: /bin/bash -c on Linux/macOS, cmd.exe /c on Windows\n- Enforce timeout: on timeout, SIGTERM to process group, wait 2s, then SIGKILL\n- Capture stdout and stderr separately, combine for result\n- Record wall-clock duration\n\n\\`\\`\\`rust\nasync fn exec_command(\u0026self, command: \u0026str, timeout_ms: u64, ...) -\u003e Result\u003cExecResult\u003e {\n    let child = tokio::process::Command::new(\"bash\")\n        .args([\"-c\", command])\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .process_group(0)  // new process group\n        .spawn()?;\n\n    tokio::select! {\n        result = child.wait_with_output() =\u003e { /* normal completion */ }\n        _ = tokio::time::sleep(Duration::from_millis(timeout_ms)) =\u003e {\n            // SIGTERM the process group\n            // Wait 2s\n            // SIGKILL if still alive\n        }\n    }\n}\n\\`\\`\\`\n\n## Environment variable filtering (spec Section 4.2)\nDefault exclude: *_API_KEY, *_SECRET, *_TOKEN, *_PASSWORD, *_CREDENTIAL (case-insensitive)\nAlways include: PATH, HOME, USER, SHELL, LANG, TERM, TMPDIR, GOPATH, CARGO_HOME, NVM_DIR\n\n## Search operations\n- grep: use ripgrep (rg) subprocess if available, fallback to regex crate\n- glob: use globset crate\n\n## Acceptance criteria\n- File read/write works with absolute and relative paths\n- Command timeout fires correctly (SIGTERM then SIGKILL)\n- Process group cleanup prevents orphan processes\n- Environment variable filtering excludes secrets\n- Platform detection returns correct value\n- grep and glob produce expected results","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:18:06.403194-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:18:06.403194-08:00","dependencies":[{"issue_id":"attractor-8qq","depends_on_id":"attractor-vsf","type":"blocks","created_at":"2026-02-10T14:26:59.158347-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-8yo","title":"Implement pipeline execution engine (core loop)","description":"# Pipeline Execution Engine (attractor-pipeline)\n\n## What\nThe heart of Attractor — the 5-phase lifecycle and core execution loop from\nattractor-spec.md Section 3.\n\n## 5-Phase Lifecycle (spec Section 3.1)\n```\nPARSE → VALIDATE → INITIALIZE → EXECUTE → FINALIZE\n```\n\n1. Parse: Read .dot source → PipelineGraph\n2. Validate: Run lint rules. Reject invalid graphs.\n3. Initialize: Create run directory, initial context, checkpoint. Mirror graph attrs. Apply transforms.\n4. Execute: Traverse graph from start, executing handlers and selecting edges.\n5. Finalize: Write final checkpoint, emit completion events, clean up.\n\n## Core Execution Loop (spec Section 3.2)\n```rust\npub async fn run(\n    \u0026self,\n    graph: \u0026PipelineGraph,\n    config: \u0026PipelineConfig,\n) -\u003e Result\u003cPipelineResult, AttractorError\u003e {\n    let mut context = Context::new();\n    mirror_graph_attributes(graph, \u0026context);\n    let mut completed_nodes = Vec::new();\n    let mut node_outcomes = HashMap::new();\n    let mut current_node = graph.start_node()?;\n\n    loop {\n        // Step 1: Check terminal\n        if is_terminal(current_node) {\n            let (ok, failed) = check_goal_gates(graph, \u0026node_outcomes);\n            if !ok {\n                if let Some(target) = get_retry_target(failed, graph) {\n                    current_node = graph.node(\u0026target)?;\n                    continue;\n                }\n                return Err(AttractorError::GoalGateUnsatisfied { ... });\n            }\n            break;\n        }\n\n        // Step 2: Execute handler with retry\n        let handler = self.registry.resolve(current_node);\n        let outcome = execute_with_retry(handler, current_node, \u0026context, graph, \u0026retry_policy).await?;\n\n        // Step 3: Record\n        completed_nodes.push(current_node.id.clone());\n        node_outcomes.insert(current_node.id.clone(), outcome.clone());\n\n        // Step 4: Apply context updates\n        context.apply_updates(\u0026outcome.context_updates);\n        context.set(\"outcome\", outcome.status.to_string());\n        if let Some(ref label) = outcome.preferred_label {\n            context.set(\"preferred_label\", label);\n        }\n\n        // Step 5: Save checkpoint\n        save_checkpoint(\u0026context, \u0026current_node.id, \u0026completed_nodes, logs_root);\n\n        // Step 6: Select next edge\n        let next = select_edge(\u0026current_node.id, \u0026outcome, \u0026context, graph);\n        if next.is_none() {\n            if outcome.status == StageStatus::Fail {\n                return Err(AttractorError::HandlerError { ... });\n            }\n            break;\n        }\n        let next_edge = next.unwrap();\n\n        // Step 7: Handle loop_restart\n        if next_edge.loop_restart {\n            return self.run_fresh(graph, config, \u0026next_edge.to).await;\n        }\n\n        // Step 8: Advance\n        current_node = graph.node(\u0026next_edge.to)?;\n    }\n\n    Ok(PipelineResult { ... })\n}\n```\n\n## PipelineExecutor\n```rust\npub struct PipelineExecutor {\n    registry: HandlerRegistry,\n    event_tx: broadcast::Sender\u003cPipelineEvent\u003e,\n}\n\npub struct PipelineConfig {\n    pub logs_root: PathBuf,\n    pub interviewer: Box\u003cdyn Interviewer\u003e,\n    pub backend: Box\u003cdyn CodergenBackend\u003e,\n}\n\npub struct PipelineResult {\n    pub outcome: Outcome,\n    pub completed_nodes: Vec\u003cString\u003e,\n    pub node_outcomes: HashMap\u003cString, Outcome\u003e,\n    pub context: Context,\n}\n```\n\n## Events emitted\n- PipelineStarted, PipelineCompleted, PipelineFailed\n- StageStarted, StageCompleted, StageFailed, StageRetrying\n- CheckpointSaved\n\n## Acceptance criteria\n- 5-phase lifecycle executes in order\n- Linear pipeline (start → A → B → exit) completes successfully\n- Branching pipeline routes based on edge conditions\n- Terminal node stops execution\n- Context updates from one node visible to next\n- Checkpoint saved after each node\n- Events emitted at each stage\n- Pipeline with 10+ nodes completes without errors","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:24.804878-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:24.804878-08:00","dependencies":[{"issue_id":"attractor-8yo","depends_on_id":"attractor-etr","type":"blocks","created_at":"2026-02-10T14:27:07.591353-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-8yo","depends_on_id":"attractor-ot2","type":"blocks","created_at":"2026-02-10T14:27:07.910121-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-8yo","depends_on_id":"attractor-dc0","type":"blocks","created_at":"2026-02-10T14:27:08.26091-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-8yo","depends_on_id":"attractor-b9f","type":"blocks","created_at":"2026-02-10T14:27:08.565881-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-8yo","depends_on_id":"attractor-28l","type":"blocks","created_at":"2026-02-10T14:27:08.891412-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-8yo","depends_on_id":"attractor-wfp","type":"blocks","created_at":"2026-02-10T14:27:09.213873-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-9hn","title":"Implement retry logic with backoff policies","description":"# Retry Logic (attractor-pipeline)\n\n## What\nImplement the per-node retry system from attractor-spec.md Sections 3.5-3.6.\n\n## Retry policy\n- max_retries on node = additional attempts beyond initial (max_retries=3 → 4 total)\n- Falls back to graph default_max_retry (default: 50)\n- Built-in default: 0 (no retries)\n\n## Backoff configuration\n```rust\npub struct BackoffConfig {\n    pub initial_delay_ms: u64,    // default: 200\n    pub backoff_factor: f64,      // default: 2.0\n    pub max_delay_ms: u64,        // default: 60000\n    pub jitter: bool,             // default: true\n}\n```\n\nDelay calculation: delay = initial * (factor ^ (attempt-1)), capped at max, ±50% jitter\n\n## Preset policies\n| Name | Max Attempts | Initial | Factor |\n|------|-------------|---------|--------|\n| none | 1 | -- | -- |\n| standard | 5 | 200ms | 2.0 |\n| aggressive | 5 | 500ms | 2.0 |\n| linear | 3 | 500ms | 1.0 |\n| patient | 3 | 2000ms | 3.0 |\n\n## execute_with_retry (spec Section 3.5)\n```rust\nasync fn execute_with_retry(handler, node, context, graph, policy) -\u003e Outcome {\n    for attempt in 1..=policy.max_attempts {\n        match handler.execute(node, context, graph, logs_root).await {\n            Ok(outcome) if outcome.status.is_success() =\u003e return outcome,\n            Ok(outcome) if outcome.status == Retry \u0026\u0026 attempt \u003c max =\u003e {\n                sleep(backoff_delay(attempt)).await;\n                continue;\n            }\n            Ok(outcome) if outcome.status == Fail =\u003e return outcome,\n            Err(e) if policy.should_retry(\u0026e) \u0026\u0026 attempt \u003c max =\u003e {\n                sleep(backoff_delay(attempt)).await;\n                continue;\n            }\n            other =\u003e return other_or_fail,\n        }\n    }\n    // Exhausted: if allow_partial, return PartialSuccess\n}\n```\n\n## Failure routing (spec Section 3.7)\nAfter retries exhausted:\n1. Fail edge (condition=\"outcome=fail\") → follow it\n2. retry_target on node → jump\n3. fallback_retry_target → jump\n4. Pipeline terminates\n\n## Acceptance criteria\n- max_retries=0 means no retries (single attempt)\n- max_retries=3 means up to 4 total attempts\n- Backoff delays calculated correctly with jitter\n- Retry counter tracked per-node in context\n- allow_partial=true returns PartialSuccess when exhausted\n- Failure routing follows 4-step fallback","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:52.704905-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:52.704905-08:00","dependencies":[{"issue_id":"attractor-9hn","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:09.523815-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-add","title":"Implement Attractor: DOT-based pipeline runner for AI workflows","description":"# Epic: Full Rust Implementation of StrongDM Attractor\n\n## Background\n\nStrongDM published Attractor (https://factory.strongdm.ai/products/attractor), a non-interactive\ncoding agent structured as a graph of phases that runs end-to-end when work is fully specified.\nThe spec repo (https://github.com/strongdm/attractor) contains 3 Natural Language Specs (NLSpecs)\ntotaling ~5700 lines that together define a complete \"Software Factory\" stack:\n\n1. **Unified LLM Client** (unified-llm-spec.md, ~2153 lines) — Provider-agnostic LLM client\n   supporting OpenAI, Anthropic, and Gemini via their native APIs\n2. **Coding Agent Loop** (coding-agent-loop-spec.md, ~1451 lines) — Autonomous agentic loop\n   pairing LLMs with developer tools (read, write, edit, shell, grep, glob)\n3. **Attractor Pipeline Engine** (attractor-spec.md, ~2083 lines) — DOT-based directed graph\n   orchestrator for multi-stage AI workflows with human-in-the-loop, parallel execution,\n   checkpointing, and goal gates\n\n## Why Rust\n\n- Performance: Pipeline execution involves concurrent node handlers, streaming LLM responses,\n  and parallel tool execution — Rust's async/await with tokio handles this efficiently\n- Safety: The type system catches edge selection bugs, handler registration errors, and\n  context access races at compile time\n- Ecosystem: reqwest for HTTP, winnow for parsing, serde for serialization — mature crates\n- Reference: codex-rs (OpenAI's agent) is in Rust, validating the language choice\n\n## Architecture\n\nCargo workspace with 7 crates, built bottom-up:\n\n```\nattractor-types    → Shared types, errors, context, outcome\nattractor-dot      → DOT parser (strict Graphviz subset)\nattractor-llm      → Unified LLM client (3 providers)\nattractor-tools    → Tool trait, built-in tools, execution environments\nattractor-agent    → Coding agent loop\nattractor-pipeline → Pipeline engine, node handlers, validation\nattractor-cli      → Binary entry point\n```\n\n## Spec Source\n\nAll specs are cloned at /tmp/attractor/ for reference. The implementation must satisfy the\n\"Definition of Done\" checklists in each spec (Sections 11, 9, and 8 respectively).\n\n## Success Criteria\n\n- All DOT examples from the spec parse correctly\n- All 12 lint rules pass on valid pipelines and catch invalid ones\n- Linear, branching, parallel, and human-gated pipelines execute correctly\n- LLM providers (OpenAI, Anthropic, Gemini) can be called via unified interface\n- Agent loop can execute multi-step coding tasks with tool usage\n- Checkpoint save/restore works for crash recovery\n- `attractor run pipeline.dot` CLI works end-to-end","notes":"## Task Breakdown (33 tasks across 5 phases)\n\n### Phase 1: Foundation (5 tasks) — No external dependencies\n- attractor-sa0: Scaffold Cargo workspace with 7 crates [ENTRY POINT]\n- attractor-mxw: AttractorError enum and error taxonomy\n- attractor-28l: Context (thread-safe key-value store)\n- attractor-wfp: Outcome, StageStatus, and Checkpoint types\n- attractor-4ac: DOT parser for strict Graphviz subset\n- attractor-rk2: Pipeline Graph model (resolved, validated)\n\n### Phase 2: LLM Client (6 tasks)\n- attractor-eg6: LLM data model (Message, Request, Response, ContentPart)\n- attractor-3zy: ProviderAdapter trait and DynProvider wrapper\n- attractor-tea: Anthropic provider adapter (Messages API) [HIGHEST PRIORITY PROVIDER]\n- attractor-d49: OpenAI provider adapter (Responses API)\n- attractor-8ki: Gemini provider adapter (native API)\n- attractor-4lf: LlmClient with middleware chain and model catalog\n\n### Phase 3: Tools + Agent (8 tasks)\n- attractor-vsf: Tool trait, ToolRegistry, ExecutionEnvironment\n- attractor-8qq: LocalExecutionEnvironment\n- attractor-0t4: Built-in tools (read_file, write_file, edit_file, shell, grep, glob)\n- attractor-376: Provider-aligned tool profiles\n- attractor-mq9: AgentSession and core agentic loop\n- attractor-xl0: Loop detection and steering injection\n- attractor-6p2: Subagent spawning and management\n- attractor-sq9: System prompt builder with project doc discovery\n\n### Phase 4: Pipeline Engine (14 tasks)\n- attractor-dc0: Pipeline validation and 12 lint rules\n- attractor-wz2: HandlerRegistry with shape-to-type mapping\n- attractor-etr: Basic node handlers (start, exit, conditional, tool)\n- attractor-c0i: CodergenHandler (LLM task handler)\n- attractor-ot2: 5-step edge selection algorithm\n- attractor-zh7: Condition expression language\n- attractor-8yo: Pipeline execution engine (core loop) [CRITICAL PATH]\n- attractor-b9f: Goal gate enforcement and retry routing\n- attractor-9hn: Retry logic with backoff policies\n- attractor-hrl: WaitHumanHandler and Interviewer system\n- attractor-qf2: ParallelHandler (fan-out) and FanInHandler\n- attractor-oeg: Model stylesheet parser and application\n- attractor-01g: AST transforms and variable expansion\n- attractor-yov: Checkpoint save/restore and crash recovery\n\n### Phase 5: Integration (6 tasks)\n- attractor-e03: CLI binary\n- attractor-pj2: Pipeline event system for observability\n- attractor-4l7: Comprehensive integration test suite\n- attractor-pmc: Context fidelity modes (P3)\n- attractor-apm: ManagerLoopHandler supervisor pattern (P3)\n- attractor-4y0: HTTP server mode (P4)\n\n## Critical Path\nsa0 → mxw → eg6 → 3zy → tea → 4lf → mq9 → c0i → 8yo → e03\nsa0 → mxw → 28l → zh7 → ot2 → 8yo\nsa0 → 4ac → rk2 → dc0 → 8yo\n\n## Spec Sources\n- /tmp/attractor/attractor-spec.md (2083 lines)\n- /tmp/attractor/coding-agent-loop-spec.md (1451 lines)\n- /tmp/attractor/unified-llm-spec.md (2153 lines)","status":"open","priority":1,"issue_type":"epic","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:13:19.328128-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:27:41.609218-08:00"}
{"id":"attractor-apm","title":"Implement ManagerLoopHandler (supervisor pattern)","description":"# Manager Loop Handler (attractor-pipeline)\n\n## What\nImplement the supervisor pattern handler from attractor-spec.md Section 4.11.\nOrchestrates observe/steer/wait cycles over a child pipeline.\n\n## Design\n- Loads child DOT file from stack.child_dotfile attribute\n- Polls child telemetry at configurable interval (default 45s)\n- Actions: observe (ingest telemetry), steer (write intervention), wait (sleep)\n- Max cycles configurable (default 1000)\n- Stop conditions evaluated via condition expression\n\n## This is a lower-priority advanced feature.\nIt enables nested pipelines where a manager oversees a worker.\nImplement after core engine is solid.\n\n## Acceptance criteria\n- Child pipeline spawned and monitored\n- Observation cycle ingests child status\n- Stop condition evaluated correctly\n- Max cycles limit respected","status":"open","priority":3,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:02.788488-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:02.788488-08:00","dependencies":[{"issue_id":"attractor-apm","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:13.16709-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-b9f","title":"Implement goal gate enforcement and retry routing","description":"# Goal Gate Enforcement (attractor-pipeline)\n\n## What\nImplement the goal gate system from attractor-spec.md Section 3.4 that prevents\npipelines from exiting until critical stages have succeeded.\n\n## Concept\nNodes with goal_gate=true are \"must succeed\" stages. When traversal reaches a\nterminal node (Msquare), the engine checks all visited goal gate nodes. If any\nhave non-success outcome, the pipeline cannot exit.\n\n## Logic (spec Section 3.4)\n```rust\nfn check_goal_gates(\n    graph: \u0026PipelineGraph,\n    node_outcomes: \u0026HashMap\u003cString, Outcome\u003e,\n) -\u003e (bool, Option\u003c\u0026PipelineNode\u003e) {\n    for (node_id, outcome) in node_outcomes {\n        let node = graph.node(node_id).unwrap();\n        if node.goal_gate {\n            if !matches!(outcome.status, StageStatus::Success | StageStatus::PartialSuccess) {\n                return (false, Some(node));\n            }\n        }\n    }\n    (true, None)\n}\n```\n\n## Retry target resolution\nWhen a goal gate is unsatisfied:\n1. Try node-level retry_target\n2. Try node-level fallback_retry_target\n3. Try graph-level retry_target\n4. Try graph-level fallback_retry_target\n5. If none found → pipeline fails with GoalGateUnsatisfied error\n\n## Acceptance criteria\n- Goal gate nodes tracked throughout execution\n- Exit blocked when any goal gate not SUCCESS or PARTIAL_SUCCESS\n- Retry target resolution follows 4-level fallback chain\n- Pipeline fails with clear error when no retry target available\n- Goal gates that were never visited are ignored (only visited ones checked)","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:36.75298-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:36.75298-08:00","dependencies":[{"issue_id":"attractor-b9f","depends_on_id":"attractor-wfp","type":"blocks","created_at":"2026-02-10T14:27:06.903096-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-b9f","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:07.275735-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-c0i","title":"Implement CodergenHandler (LLM task handler)","description":"# CodergenHandler: LLM Task Handler (attractor-pipeline)\n\n## What\nThe default handler for all nodes that invoke an LLM, per attractor-spec.md Section 4.5.\nThis is the most important handler — it's what makes Attractor an AI workflow engine.\n\n## Execution flow\n1. Build prompt: use node.prompt, fallback to node.label. Expand $goal variable.\n2. Write prompt to logs: {logs_root}/{node_id}/prompt.md\n3. Call LLM backend via CodergenBackend trait\n4. Write response to logs: {logs_root}/{node_id}/response.md\n5. Write status.json and return Outcome\n\n## CodergenBackend interface (spec Section 4.5)\n```rust\npub trait CodergenBackend: Send + Sync {\n    async fn run(\n        \u0026self,\n        node: \u0026PipelineNode,\n        prompt: \u0026str,\n        context: \u0026Context,\n    ) -\u003e Result\u003cCodergenResult, AttractorError\u003e;\n}\n\npub enum CodergenResult {\n    Text(String),           // Simple text response\n    Outcome(Outcome),       // Full outcome with routing hints\n}\n```\n\n## Backend implementations\n1. AgentSessionBackend — wraps a full AgentSession for each node (richest)\n2. DirectLlmBackend — calls LlmClient.complete() directly (simpler, no tools)\n3. SubprocessBackend — shells out to claude/codex/gemini CLI\n4. SimulationBackend — returns \"[Simulated] Response for stage: {node_id}\"\n\n## Variable expansion\nOnly $goal is built-in. Simple string replacement, not a templating engine.\n\n## Status file contract (spec Appendix C)\n```json\n{\n    \"outcome\": \"success\",\n    \"preferred_next_label\": \"\",\n    \"suggested_next_ids\": [],\n    \"context_updates\": {\"last_stage\": \"node_id\", \"last_response\": \"truncated...\"},\n    \"notes\": \"Stage completed: node_id\"\n}\n```\n\nWhen auto_status=true and no status.json written → engine synthesizes success.\n\n## Acceptance criteria\n- Prompt built correctly with $goal expansion\n- prompt.md and response.md written to stage directory\n- status.json written with Outcome fields\n- Backend pluggable (different backends swappable without changing DOT file)\n- Simulation mode works (no LLM needed)\n- Error in backend → Outcome with status: Fail","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:30.375888-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:30.375888-08:00","dependencies":[{"issue_id":"attractor-c0i","depends_on_id":"attractor-wz2","type":"blocks","created_at":"2026-02-10T14:27:06.18169-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-c0i","depends_on_id":"attractor-mq9","type":"blocks","created_at":"2026-02-10T14:27:06.544418-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-d49","title":"Implement OpenAI provider adapter (Responses API)","description":"# OpenAI Provider Adapter (attractor-llm)\n\n## What\nImplement the OpenAI adapter using the Responses API (/v1/responses), NOT the\nChat Completions API.\n\n## Why Responses API (spec Section 2.7)\nThe Responses API properly surfaces reasoning tokens for GPT-5.2 series, supports\nbuilt-in tools (web search, file search, code interpreter), and is OpenAI's\nforward-looking API. Chat Completions does NOT return reasoning tokens for reasoning\nmodels and lacks server-side conversation state.\n\n## Key differences from Chat Completions\n- Endpoint: POST /v1/responses (not /v1/chat/completions)\n- Server-side conversation state (previous_response_id)\n- Reasoning tokens visible in usage\n- Built-in tool support (web_search_preview, etc.)\n\n## Request/Response translation\nStandard mapping from unified types to OpenAI Responses API JSON format.\nreasoning_effort maps to reasoning.effort field on request.\n\n## Streaming\nOpenAI SSE events for Responses API.\n\n## Prompt caching\nAUTOMATIC for OpenAI — no SDK action required. Just report cache_read_tokens from usage.\n\n## Acceptance criteria\n- complete() calls /v1/responses correctly\n- stream() parses OpenAI SSE events\n- Reasoning effort passed through\n- Usage includes reasoning_tokens\n- Cache statistics reported\n- Proper error mapping","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:17:05.00477-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:17:05.00477-08:00","dependencies":[{"issue_id":"attractor-d49","depends_on_id":"attractor-3zy","type":"blocks","created_at":"2026-02-10T14:26:57.217407-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-dc0","title":"Implement pipeline validation and 12 built-in lint rules","description":"# Pipeline Validation \u0026 Linting (attractor-pipeline)\n\n## What\nImplement the validation system from attractor-spec.md Section 7 that ensures pipeline\ngraphs are structurally sound before execution.\n\n## Why\nValidation catches errors early — before spending LLM tokens or time on execution.\nThe engine MUST refuse to execute a pipeline with error-severity diagnostics.\n\n## Diagnostic model (spec Section 7.1)\n```rust\npub struct Diagnostic {\n    pub rule: String,\n    pub severity: Severity,\n    pub message: String,\n    pub node_id: Option\u003cString\u003e,\n    pub edge: Option\u003c(String, String)\u003e,\n    pub fix: Option\u003cString\u003e,\n}\n\npub enum Severity { Error, Warning, Info }\n```\n\n## 12 Built-in Lint Rules (spec Section 7.2)\n\n### Error severity (pipeline will NOT execute):\n1. start_node — Exactly one start node (shape=Mdiamond or id start/Start)\n2. terminal_node — At least one terminal node (shape=Msquare or id exit/end)\n3. reachability — All nodes reachable from start via BFS/DFS\n4. edge_target_exists — Every edge target references an existing node ID\n5. start_no_incoming — Start node has no incoming edges\n6. exit_no_outgoing — Exit node has no outgoing edges\n7. condition_syntax — Edge condition expressions parse correctly\n8. stylesheet_syntax — model_stylesheet parses as valid stylesheet\n\n### Warning severity (pipeline executes but may misbehave):\n9. type_known — Node type values recognized by handler registry\n10. fidelity_valid — Fidelity values are one of the 6 valid modes\n11. retry_target_exists — retry_target and fallback_retry_target reference existing nodes\n12. goal_gate_has_retry — Nodes with goal_gate=true should have a retry target\n13. prompt_on_llm_nodes — Codergen nodes should have prompt or label\n\n## LintRule trait (spec Section 7.4)\n```rust\npub trait LintRule: Send + Sync {\n    fn name(\u0026self) -\u003e \u0026str;\n    fn apply(\u0026self, graph: \u0026PipelineGraph) -\u003e Vec\u003cDiagnostic\u003e;\n}\n```\n\n## Validation API\n- validate(graph, extra_rules) -\u003e Vec\u003cDiagnostic\u003e\n- validate_or_raise(graph, extra_rules) -\u003e Result\u003cVec\u003cDiagnostic\u003e, AttractorError\u003e\n  Raises ValidationError if any error-severity diagnostics found\n\n## Acceptance criteria\n- All 12+ rules implemented and tested individually\n- validate_or_raise rejects graphs with error-severity violations\n- Warnings don't block execution\n- Diagnostics include rule name, severity, message, affected node/edge, suggested fix\n- Custom rules can be registered\n- Reachability uses BFS from start node","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:22:48.689107-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:22:48.689107-08:00","dependencies":[{"issue_id":"attractor-dc0","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:02.822821-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-e03","title":"Implement attractor CLI binary","description":"# CLI Binary (attractor-cli)\n\n## What\nThe entry point binary that wires all crates together and provides the user interface.\n\n## Commands\n- attractor run \u003cpipeline.dot\u003e — parse, validate, execute pipeline\n  --backend \u003cbackend\u003e — claude-code, codex, gemini-cli, direct, simulate\n  --interviewer \u003cmode\u003e — auto, console\n  --logs-dir \u003cpath\u003e — where to write run artifacts (default: ./attractor-logs/\u003ctimestamp\u003e)\n  --resume \u003ccheckpoint-path\u003e — resume from checkpoint\n  --model \u003cmodel\u003e — override LLM model for all nodes\n  --provider \u003cprovider\u003e — override LLM provider\n  --reasoning-effort \u003clevel\u003e — low, medium, high\n\n- attractor validate \u003cpipeline.dot\u003e — parse and lint only, show diagnostics\n- attractor lint \u003cpipeline.dot\u003e — detailed lint output with suggestions\n\n- attractor graph \u003cpipeline.dot\u003e — render pipeline as ASCII or generate DOT for Graphviz\n- attractor version — print version\n\n## Configuration\n- API keys from environment: OPENAI_API_KEY, ANTHROPIC_API_KEY, GEMINI_API_KEY\n- Optional config file: attractor.toml or .attractor/config.toml\n\n## Implementation\nUse clap 4 with derive API for arg parsing.\nWire up: DOT parser → validator → transforms → executor with chosen backend/interviewer.\nSet up tracing subscriber for structured logging.\n\n## Acceptance criteria\n- attractor run pipeline.dot works end-to-end with simulation backend\n- attractor validate catches errors and prints diagnostics\n- --resume flag loads checkpoint and continues execution\n- --backend simulate runs without any API keys\n- Help text is clear and complete\n- Exit codes: 0=success, 1=pipeline failure, 2=validation error","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:28.553668-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:28.553668-08:00","dependencies":[{"issue_id":"attractor-e03","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:13.487618-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-e03","depends_on_id":"attractor-c0i","type":"blocks","created_at":"2026-02-10T14:27:13.801493-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-e03","depends_on_id":"attractor-hrl","type":"blocks","created_at":"2026-02-10T14:27:14.139608-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-eg6","title":"Implement LLM data model (Message, Request, Response, ContentPart)","description":"# LLM Data Model (attractor-llm)\n\n## What\nImplement the core data types from unified-llm-spec.md Sections 3.1-3.5 that all\nLLM communication flows through.\n\n## Why\nThese types form the contract between the agent loop and LLM providers. Getting them\nright is critical because:\n- Every provider adapter translates to/from these types\n- The agent loop builds Requests and processes Responses\n- ContentPart must handle text, images, tool calls, thinking blocks, and caching\n\n## Types\n\n### Message (Section 3.1)\n```rust\npub struct Message {\n    pub role: Role,\n    pub content: Vec\u003cContentPart\u003e,\n    pub name: Option\u003cString\u003e,\n    pub tool_call_id: Option\u003cString\u003e,\n}\n```\nConvenience constructors: Message::system(text), Message::user(text),\nMessage::assistant(text), Message::tool_result(id, content, is_error)\n\n### Role (Section 3.2)\nSystem, User, Assistant, Tool, Developer — maps differently per provider:\n- OpenAI: system, user, assistant, tool, developer\n- Anthropic: system extracted to parameter, user, assistant, tool_result in user msg\n- Gemini: systemInstruction, user, model, functionResponse in user\n\n### ContentPart (Section 3.3) — Tagged union\n```rust\npub enum ContentPart {\n    Text { text: String },\n    Image { url: Option\u003cString\u003e, data: Option\u003cVec\u003cu8\u003e\u003e, media_type: Option\u003cString\u003e, detail: Option\u003cString\u003e },\n    Audio { url: Option\u003cString\u003e, data: Option\u003cVec\u003cu8\u003e\u003e, media_type: Option\u003cString\u003e },\n    Document { url: Option\u003cString\u003e, data: Option\u003cVec\u003cu8\u003e\u003e, media_type: Option\u003cString\u003e },\n    ToolCall { id: String, name: String, arguments: serde_json::Value },\n    ToolResult { tool_call_id: String, content: String, is_error: bool },\n    Thinking { text: String, signature: Option\u003cString\u003e },\n    RedactedThinking { data: String },\n}\n```\n\n### Request / Response\n```rust\npub struct Request {\n    pub model: String,\n    pub messages: Vec\u003cMessage\u003e,\n    pub tools: Vec\u003cToolDefinition\u003e,\n    pub tool_choice: Option\u003cToolChoice\u003e,\n    pub max_tokens: Option\u003cu32\u003e,\n    pub temperature: Option\u003cf32\u003e,\n    pub stop_sequences: Vec\u003cString\u003e,\n    pub reasoning_effort: Option\u003cReasoningEffort\u003e,\n    pub provider: Option\u003cString\u003e,\n    pub provider_options: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n}\n\npub struct Response {\n    pub id: String,\n    pub text: String,           // concatenated text parts\n    pub tool_calls: Vec\u003cToolCall\u003e,\n    pub reasoning: Option\u003cString\u003e,\n    pub usage: Usage,\n    pub model: String,\n    pub finish_reason: FinishReason,\n}\n\npub struct Usage {\n    pub input_tokens: u64,\n    pub output_tokens: u64,\n    pub reasoning_tokens: Option\u003cu64\u003e,\n    pub cache_read_tokens: Option\u003cu64\u003e,\n    pub cache_write_tokens: Option\u003cu64\u003e,\n    pub total_tokens: u64,\n}\n```\n\n### ToolDefinition / ToolCall / ToolResult (Section 5)\n```rust\npub struct ToolDefinition {\n    pub name: String,\n    pub description: String,\n    pub parameters: serde_json::Value, // JSON Schema\n}\npub struct ToolCall { pub id: String, pub name: String, pub arguments: serde_json::Value }\npub struct ToolResult { pub tool_call_id: String, pub content: String, pub is_error: bool }\n```\n\n### StreamEvent\n```rust\npub enum StreamEvent {\n    ContentStart,\n    ContentDelta { text: String },\n    ContentEnd,\n    ToolCallStart { id: String, name: String },\n    ToolCallDelta { id: String, json_chunk: String },\n    ToolCallEnd { id: String },\n    ThinkingDelta { text: String },\n    MessageStart { id: String, model: String },\n    MessageEnd { usage: Usage, finish_reason: FinishReason },\n    Error(AttractorError),\n}\n```\n\n## Acceptance criteria\n- All types derive Debug, Clone, Serialize, Deserialize where appropriate\n- Message convenience constructors work\n- ContentPart serializes/deserializes as tagged union\n- Usage tracks all token types including cache stats\n- FinishReason covers: EndTurn, MaxTokens, StopSequence, ToolUse","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:16:24.753463-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:16:24.753463-08:00","dependencies":[{"issue_id":"attractor-eg6","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:26:55.894815-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-eg6","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:56.259097-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-etr","title":"Implement basic node handlers (start, exit, conditional, tool)","description":"# Basic Node Handlers (attractor-pipeline)\n\n## What\nImplement the simpler handlers that don't require LLM integration.\n\n## StartHandler (spec Section 4.3)\nNo-op. Returns Outcome { status: Success } immediately.\nEvery graph must have exactly one start node (shape=Mdiamond).\n\n## ExitHandler (spec Section 4.4)\nNo-op. Returns Outcome { status: Success } immediately.\nGoal gate enforcement is handled by the engine, not this handler.\nEvery graph must have exactly one exit node (shape=Msquare).\n\n## ConditionalHandler (spec Section 4.7)\nNo-op pass-through. Returns Outcome { status: Success }.\nThe actual routing logic is in the engine's edge selection algorithm.\nThis design keeps routing logic in the engine where it's deterministic and inspectable.\n\n## ToolHandler (spec Section 4.10)\nExecutes external tool/shell command from node attributes.\n```rust\nfn execute(\u0026self, node, context, graph, logs_root) -\u003e Outcome {\n    let command = node.raw_attrs.get(\"tool_command\")?;\n    let result = exec_command(command, node.timeout)?;\n    Outcome { status: Success, context_updates: {\"tool.output\": result.stdout} }\n}\n```\n\n## Acceptance criteria\n- Start/Exit/Conditional return Success immediately\n- ToolHandler reads tool_command attribute and executes it\n- ToolHandler respects node timeout\n- ToolHandler catches execution errors and returns Fail outcome\n- All handlers write status.json to logs_root/{node_id}/","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:13.806749-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:13.806749-08:00","dependencies":[{"issue_id":"attractor-etr","depends_on_id":"attractor-wz2","type":"blocks","created_at":"2026-02-10T14:27:03.794401-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-etr","depends_on_id":"attractor-28l","type":"blocks","created_at":"2026-02-10T14:27:04.149857-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-etr","depends_on_id":"attractor-wfp","type":"blocks","created_at":"2026-02-10T14:27:04.473302-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-hrl","title":"Implement WaitHumanHandler and Interviewer system","description":"# Human-in-the-Loop (attractor-pipeline)\n\n## What\nImplement the Interviewer pattern and WaitHumanHandler from attractor-spec.md Section 6.\n\n## Interviewer trait (spec Section 6.1)\n```rust\npub trait Interviewer: Send + Sync {\n    async fn ask(\u0026self, question: Question) -\u003e Result\u003cAnswer, AttractorError\u003e;\n    async fn ask_multiple(\u0026self, questions: Vec\u003cQuestion\u003e) -\u003e Result\u003cVec\u003cAnswer\u003e, AttractorError\u003e;\n    fn inform(\u0026self, message: \u0026str, stage: \u0026str);\n}\n```\n\n## Question/Answer models (spec Sections 6.2-6.3)\n```rust\npub struct Question {\n    pub text: String,\n    pub question_type: QuestionType,\n    pub options: Vec\u003cQuestionOption\u003e,\n    pub default: Option\u003cAnswer\u003e,\n    pub timeout_seconds: Option\u003cf64\u003e,\n    pub stage: String,\n}\npub enum QuestionType { YesNo, MultipleChoice, Freeform, Confirmation }\npub struct QuestionOption { pub key: String, pub label: String }\n\npub struct Answer {\n    pub value: AnswerValue,\n    pub selected_option: Option\u003cQuestionOption\u003e,\n    pub text: Option\u003cString\u003e,\n}\npub enum AnswerValue { Yes, No, Selected(String), Skipped, Timeout }\n```\n\n## WaitHumanHandler (spec Section 4.6)\n1. Derive choices from outgoing edges\n2. Parse accelerator keys from edge labels ([Y] Label, Y) Label, Y - Label)\n3. Present to Interviewer\n4. Handle timeout (use human.default_choice attribute or return Retry)\n5. Return Outcome with suggested_next_ids pointing to selected edge target\n\n## Built-in Interviewer implementations (spec Section 6.4)\n- AutoApproveInterviewer: always YES or first option (for CI/testing)\n- ConsoleInterviewer: reads from stdin with formatted prompts\n- CallbackInterviewer: delegates to provided function\n- QueueInterviewer: reads from pre-filled queue (for deterministic testing)\n- RecordingInterviewer: wraps another and records all Q\u0026A pairs\n\n## Acceptance criteria\n- WaitHumanHandler derives choices from outgoing edges correctly\n- Accelerator key parsing works for all patterns\n- Console interviewer displays formatted options and reads input\n- AutoApprove selects first option (for testing)\n- Timeout handling uses default choice or returns Retry\n- RecordingInterviewer captures all interactions for replay","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:25:07.639476-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:25:07.639476-08:00","dependencies":[{"issue_id":"attractor-hrl","depends_on_id":"attractor-wz2","type":"blocks","created_at":"2026-02-10T14:27:09.846042-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-hrl","depends_on_id":"attractor-28l","type":"blocks","created_at":"2026-02-10T14:27:10.215368-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-mq9","title":"Implement AgentSession and core agentic loop","description":"# AgentSession: Core Agentic Loop (attractor-agent)\n\n## What\nImplement the centerpiece of the coding agent spec — the agentic loop that coordinates\nLLM calls, tool execution, and state management.\n\n## The Core Loop (spec Section 2.5)\n\\`\\`\\`\nprocess_input(session, user_input):\n    append UserTurn to history\n    drain steering queue\n\n    LOOP:\n        check turn limits\n        check abort signal\n        build LLM request (system prompt + history + tools)\n        call LLM via complete()\n        record AssistantTurn\n        if no tool calls → BREAK (natural completion)\n        execute tool calls through execution environment\n        append ToolResultsTurn\n        drain steering queue\n        check loop detection\n    END LOOP\n\n    if follow-up queue not empty → process next\n    set state to IDLE\n\\`\\`\\`\n\n## Session struct\n\\`\\`\\`rust\npub struct AgentSession {\n    id: String,\n    profile: ProviderProfile,\n    llm_client: LlmClient,\n    env: Box\u003cdyn ExecutionEnvironment\u003e,\n    history: Vec\u003cTurn\u003e,\n    config: SessionConfig,\n    state: SessionState,\n    steering_tx: mpsc::Sender\u003cString\u003e,\n    steering_rx: mpsc::Receiver\u003cString\u003e,\n    followup_queue: VecDeque\u003cString\u003e,\n    event_tx: broadcast::Sender\u003cAgentEvent\u003e,\n}\n\npub struct SessionConfig {\n    pub max_turns: usize,                    // 0 = unlimited\n    pub max_tool_rounds_per_input: usize,    // default 200\n    pub default_command_timeout_ms: u64,     // 10000\n    pub max_command_timeout_ms: u64,         // 600000\n    pub reasoning_effort: Option\u003cString\u003e,\n    pub enable_loop_detection: bool,\n    pub loop_detection_window: usize,        // 10\n}\n\npub enum SessionState { Idle, Processing, AwaitingInput, Closed }\npub enum Turn { User(UserTurn), Assistant(AssistantTurn), ToolResults(ToolResultsTurn), System(SystemTurn), Steering(SteeringTurn) }\n\\`\\`\\`\n\n## Key behaviors\n1. Steering: steer() queues message via mpsc channel, drained between tool rounds\n2. Follow-up: follow_up() queues for after current input completes\n3. Stop conditions: natural completion (no tool calls), round limit, turn limit, abort, error\n4. Tool calls executed through ExecutionEnvironment, results truncated before LLM sees them\n\n## Acceptance criteria\n- Loop runs until natural completion (no tool calls in response)\n- Round limit stops loop correctly\n- Steering messages injected between tool rounds\n- Follow-up messages processed after current input\n- Tool calls dispatched through ToolRegistry\n- Events emitted at each stage (turn start, tool call, etc.)\n- State transitions correct (Idle → Processing → Idle)","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:18:59.243189-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:18:59.243189-08:00","dependencies":[{"issue_id":"attractor-mq9","depends_on_id":"attractor-4lf","type":"blocks","created_at":"2026-02-10T14:27:00.769325-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-mq9","depends_on_id":"attractor-0t4","type":"blocks","created_at":"2026-02-10T14:27:01.091909-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-mq9","depends_on_id":"attractor-376","type":"blocks","created_at":"2026-02-10T14:27:01.410046-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-mxw","title":"Implement AttractorError enum and error taxonomy","description":"# Error Taxonomy (attractor-types)\n\n## What\nDefine the unified error enum that all crates use, following the error categories\nfrom the specs (Attractor Appendix D, Unified LLM Section 6, Agent Loop Appendix B).\n\n## Why\nA well-designed error enum is critical because:\n- Pipeline retry logic matches on error variants to decide retryable vs terminal\n- The agent loop needs to distinguish tool errors (recoverable) from auth errors (fatal)\n- Provider adapters need to map HTTP status codes to typed errors\n\n## Design\n\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum AttractorError {\n    // === LLM Provider Errors ===\n    #[error(\"Provider {provider} returned HTTP {status}: {message}\")]\n    ProviderError { provider: String, status: u16, message: String, retryable: bool },\n\n    #[error(\"Rate limited by {provider}, retry after {retry_after_ms}ms\")]\n    RateLimited { provider: String, retry_after_ms: u64 },\n\n    #[error(\"Authentication failed for provider {provider}\")]\n    AuthError { provider: String },\n\n    #[error(\"Request to {provider} timed out after {timeout_ms}ms\")]\n    RequestTimeout { provider: String, timeout_ms: u64 },\n\n    #[error(\"Context length exceeded for {provider}: {message}\")]\n    ContextLengthExceeded { provider: String, message: String },\n\n    // === Parser Errors ===\n    #[error(\"DOT parse error at line {line}, col {col}: {message}\")]\n    ParseError { line: usize, col: usize, message: String, source_snippet: Option\u003cString\u003e },\n\n    // === Pipeline Errors ===\n    #[error(\"Pipeline validation failed: {0}\")]\n    ValidationError(String),\n\n    #[error(\"Handler '{handler}' failed on node '{node}': {message}\")]\n    HandlerError { handler: String, node: String, message: String },\n\n    #[error(\"Goal gate unsatisfied: node '{node}' did not reach SUCCESS\")]\n    GoalGateUnsatisfied { node: String },\n\n    #[error(\"No retry target for failed goal gate '{node}'\")]\n    NoRetryTarget { node: String },\n\n    #[error(\"Max retries exhausted for node '{node}' after {attempts} attempts\")]\n    RetriesExhausted { node: String, attempts: usize },\n\n    // === Tool Errors ===\n    #[error(\"Tool '{tool}' error: {message}\")]\n    ToolError { tool: String, message: String },\n\n    #[error(\"Command timed out after {timeout_ms}ms\")]\n    CommandTimeout { timeout_ms: u64 },\n\n    // === Agent Errors ===\n    #[error(\"Agent loop detected after {window} consecutive identical tool calls\")]\n    LoopDetected { window: usize },\n\n    #[error(\"Turn limit reached: {turns} turns\")]\n    TurnLimitReached { turns: usize },\n\n    // === Generic ===\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"JSON error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"{0}\")]\n    Other(String),\n}\n```\n\n## Key methods to implement\n- `is_retryable(\u0026self) -\u003e bool` — used by retry logic throughout the system\n- `is_terminal(\u0026self) -\u003e bool` — auth errors, validation errors = stop immediately\n- `http_status(\u0026self) -\u003e Option\u003cu16\u003e` — for HTTP server mode\n\n## Acceptance criteria\n- All error variants compile with thiserror\n- `is_retryable()` returns true for RateLimited, retryable ProviderError, CommandTimeout\n- `is_terminal()` returns true for AuthError, ValidationError, ContextLengthExceeded\n- Display strings are human-readable and include enough context for debugging\n- From impls for std::io::Error and serde_json::Error","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:15:23.791703-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:15:23.791703-08:00","dependencies":[{"issue_id":"attractor-mxw","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:52.984203-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-oeg","title":"Implement model stylesheet parser and application","description":"# Model Stylesheet (attractor-pipeline)\n\n## What\nParse and apply CSS-like model configuration rules from attractor-spec.md Section 8.\n\n## Grammar (spec Section 8.2)\n```\nStylesheet ::= Rule+\nRule       ::= Selector '{' Declaration (';' Declaration)* ';'? '}'\nSelector   ::= '*' | '#' Identifier | '.' ClassName\nDeclaration::= Property ':' PropertyValue\nProperty   ::= 'llm_model' | 'llm_provider' | 'reasoning_effort'\n```\n\n## Selectors and specificity (spec Section 8.3)\n| Selector | Matches | Specificity |\n|----------|---------|-------------|\n| * | All nodes | 0 (lowest) |\n| .class | Nodes with class | 1 |\n| #node_id | Specific node | 2 (highest) |\n\nLater rules of equal specificity override earlier ones.\nExplicit node attributes always override stylesheet values.\n\n## Application order (spec Section 8.5)\n1. Explicit node attribute (highest precedence)\n2. Stylesheet rule by specificity (ID \u003e class \u003e universal)\n3. Graph-level default\n4. Handler/system default\n\n## Applied as AST transform after parsing, before validation.\n\n## Acceptance criteria\n- Stylesheet parses from graph model_stylesheet attribute\n- * selector matches all nodes\n- .class selector matches nodes with that class\n- #id selector matches specific node\n- Specificity ordering correct\n- Explicit node attributes override stylesheet\n- Applied properties: llm_model, llm_provider, reasoning_effort","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:25:32.253887-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:25:32.253887-08:00","dependencies":[{"issue_id":"attractor-oeg","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:10.868982-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-ot2","title":"Implement 5-step edge selection algorithm","description":"# Edge Selection Algorithm (attractor-pipeline)\n\n## What\nImplement the deterministic edge selection algorithm from attractor-spec.md Section 3.3.\nThis is how the engine decides which edge to follow after a node completes.\n\n## 5-Step Priority (spec Section 3.3)\n\n### Step 1: Condition-matching edges\nEvaluate each edge's condition expression against current context and outcome.\nEdges whose condition is true are eligible. Edges with no condition skip this step.\nIf any condition-matching edges found → pick best by weight then lexical.\n\n### Step 2: Preferred label match\nIf outcome includes preferred_label, find first eligible edge whose label matches\nafter normalization. Normalization: lowercase, trim whitespace, strip accelerator\nprefixes ([Y] , Y) , Y - patterns).\n\n### Step 3: Suggested next IDs\nIf no label match and outcome has suggested_next_ids, find first eligible edge\nwhose target node ID appears in the list.\n\n### Step 4: Highest weight\nAmong remaining unconditional edges, choose highest weight (default 0).\n\n### Step 5: Lexical tiebreak\nIf weights equal, choose edge whose target node ID comes first lexicographically.\n\n## Implementation\n```rust\npub fn select_edge(\n    node_id: \u0026str,\n    outcome: \u0026Outcome,\n    context: \u0026Context,\n    graph: \u0026PipelineGraph,\n) -\u003e Option\u003c\u0026PipelineEdge\u003e {\n    let edges = graph.outgoing_edges(node_id);\n    if edges.is_empty() { return None; }\n\n    // Step 1: Condition matching\n    let condition_matched: Vec\u003c_\u003e = edges.iter()\n        .filter(|e| e.condition.is_some())\n        .filter(|e| evaluate_condition(e.condition.as_ref().unwrap(), outcome, context))\n        .collect();\n    if !condition_matched.is_empty() {\n        return Some(best_by_weight_then_lexical(\u0026condition_matched));\n    }\n\n    // Step 2: Preferred label\n    if let Some(ref label) = outcome.preferred_label {\n        for edge in edges {\n            if normalize_label(\u0026edge.label) == normalize_label(label) {\n                return Some(edge);\n            }\n        }\n    }\n\n    // Step 3: Suggested next IDs\n    for suggested_id in \u0026outcome.suggested_next_ids {\n        for edge in edges {\n            if edge.to == *suggested_id { return Some(edge); }\n        }\n    }\n\n    // Step 4 \u0026 5: Weight with lexical tiebreak (unconditional only)\n    let unconditional: Vec\u003c_\u003e = edges.iter()\n        .filter(|e| e.condition.is_none())\n        .collect();\n    if !unconditional.is_empty() {\n        return Some(best_by_weight_then_lexical(\u0026unconditional));\n    }\n\n    // Fallback: any edge\n    Some(best_by_weight_then_lexical(edges))\n}\n```\n\n## Label normalization\n- Lowercase\n- Trim whitespace\n- Strip accelerator prefixes: [Y] , Y) , Y -\n\n## Acceptance criteria\n- Condition match wins over all other steps\n- Preferred label match wins over weight\n- Suggested IDs win over weight\n- Weight breaks ties among unconditional edges\n- Lexical tiebreak as final fallback\n- Empty condition = unconditional edge\n- Label normalization strips accelerator prefixes correctly\n- Comprehensive test cases for each priority step","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:48.50336-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:48.50336-08:00","dependencies":[{"issue_id":"attractor-ot2","depends_on_id":"attractor-zh7","type":"blocks","created_at":"2026-02-10T14:27:05.472582-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-ot2","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:05.800783-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-pj2","title":"Implement pipeline event system for observability","description":"# Pipeline Event System (attractor-pipeline)\n\n## What\nImplement the typed event system from attractor-spec.md Section 9.6 for UI, logging,\nand metrics integration.\n\n## Events\n### Pipeline lifecycle:\n- PipelineStarted { name, id }\n- PipelineCompleted { duration, artifact_count }\n- PipelineFailed { error, duration }\n\n### Stage lifecycle:\n- StageStarted { name, index }\n- StageCompleted { name, index, duration }\n- StageFailed { name, index, error, will_retry }\n- StageRetrying { name, index, attempt, delay }\n\n### Parallel execution:\n- ParallelStarted { branch_count }\n- ParallelBranchStarted { branch, index }\n- ParallelBranchCompleted { branch, index, duration, success }\n- ParallelCompleted { duration, success_count, failure_count }\n\n### Human interaction:\n- InterviewStarted { question, stage }\n- InterviewCompleted { question, answer, duration }\n- InterviewTimeout { question, stage, duration }\n\n### Checkpoint:\n- CheckpointSaved { node_id }\n\n## Delivery\nVia tokio::sync::broadcast channel. Multiple consumers (CLI output, logging, metrics).\n\n## Acceptance criteria\n- All event types defined and emitted at correct times\n- broadcast channel delivers to multiple consumers\n- Events include timestamps\n- Events serializable for logging/replay","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:38.076274-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:38.076274-08:00","dependencies":[{"issue_id":"attractor-pj2","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:12.508847-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-pmc","title":"Implement context fidelity modes (full, truncate, compact, summary)","description":"# Context Fidelity (attractor-pipeline)\n\n## What\nImplement the context fidelity system from attractor-spec.md Section 5.4 that controls\nhow much prior conversation is carried into each node's LLM session.\n\n## Modes\n| Mode | Session | Context Carried | Token Budget |\n|------|---------|----------------|--------------|\n| full | Reused (same thread) | Full history | Unbounded |\n| truncate | Fresh | Only graph goal and run ID | Minimal |\n| compact | Fresh | Bullet-point summary of stages/outcomes | Moderate |\n| summary:low | Fresh | Brief summary with minimal counts | ~600 tokens |\n| summary:medium | Fresh | Moderate detail: recent outcomes, active values | ~1500 tokens |\n| summary:high | Fresh | Detailed: many events, tool summaries | ~3000 tokens |\n\n## Resolution precedence (highest to lowest)\n1. Edge fidelity attribute (incoming edge)\n2. Target node fidelity attribute\n3. Graph default_fidelity\n4. Default: compact\n\n## Thread resolution (for full fidelity)\n1. Target node thread_id\n2. Edge thread_id\n3. Graph default thread\n4. Derived class from enclosing subgraph\n5. Fallback: previous node ID\n\n## Acceptance criteria\n- All 6 fidelity modes produce appropriate context\n- Resolution follows 4-level precedence correctly\n- full mode reuses LLM session via thread_id\n- truncate mode starts fresh with minimal context\n- compact mode generates bullet-point summary\n- Summary modes respect approximate token budgets","status":"open","priority":3,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:57.90652-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:57.90652-08:00","dependencies":[{"issue_id":"attractor-pmc","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:12.83079-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-qf2","title":"Implement ParallelHandler (fan-out) and FanInHandler","description":"# Parallel Execution Handlers (attractor-pipeline)\n\n## What\nImplement ParallelHandler (fan-out) and FanInHandler from attractor-spec.md Sections 4.8-4.9.\n\n## ParallelHandler (spec Section 4.8)\nFans out to multiple branches concurrently. Each branch gets isolated context clone.\n\n```rust\nasync fn execute(\u0026self, node, context, graph, logs_root) -\u003e Outcome {\n    let branches = graph.outgoing_edges(\u0026node.id);\n    let join_policy = node.attrs.get(\"join_policy\").unwrap_or(\"wait_all\");\n    let max_parallel = node.attrs.get(\"max_parallel\").unwrap_or(4);\n\n    let mut join_set = JoinSet::new();\n    for branch in branches {\n        let branch_ctx = context.clone_isolated();\n        join_set.spawn(async move {\n            execute_subgraph(branch.to, branch_ctx, graph, logs_root).await\n        });\n    }\n\n    // Collect results based on join policy\n    // Store in context for downstream fan-in\n}\n```\n\nJoin policies: wait_all, k_of_n, first_success, quorum\nError policies: fail_fast, continue, ignore\n\n## FanInHandler (spec Section 4.9)\nConsolidates results from parallel branches. Selects best candidate.\n- If node has prompt: LLM-based evaluation\n- If no prompt: heuristic (rank by status, then score, then ID)\n\n## Acceptance criteria\n- ParallelHandler executes branches concurrently via JoinSet\n- Each branch gets isolated context (mutations don't cross)\n- Join policies work correctly (wait_all, first_success)\n- Error policies work (fail_fast cancels remaining branches)\n- FanInHandler reads parallel.results from context\n- Heuristic selection ranks Success \u003e PartialSuccess \u003e Retry \u003e Fail\n- max_parallel limits concurrency","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:25:20.40988-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:25:20.40988-08:00","dependencies":[{"issue_id":"attractor-qf2","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:10.560884-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-rk2","title":"Implement Pipeline Graph model (resolved, validated)","description":"# Pipeline Graph Model (attractor-dot)\n\n## What\nTransform the raw DOT AST into a resolved, validated Pipeline Graph model that the\nexecution engine consumes. This is the bridge between parsing and execution.\n\n## Why\nThe raw DOT AST has unresolved defaults, unexpanded chained edges, and unmerged\nsubgraph attributes. The pipeline engine needs a clean, fully-resolved graph where:\n- Every node has its final attribute values (defaults merged)\n- Every edge is a simple from→to pair (no chains)\n- Subgraph scoping is already applied\n- Typed attribute accessors are available (get_shape(), get_prompt(), etc.)\n\n## Design\n```rust\npub struct PipelineGraph {\n    pub name: String,\n    pub goal: String,\n    pub attrs: HashMap\u003cString, AttributeValue\u003e,\n    nodes: HashMap\u003cString, PipelineNode\u003e,\n    edges: Vec\u003cPipelineEdge\u003e,\n    adjacency: HashMap\u003cString, Vec\u003cusize\u003e\u003e, // node_id -\u003e edge indices\n}\n\npub struct PipelineNode {\n    pub id: String,\n    pub label: String,\n    pub shape: String,\n    pub node_type: Option\u003cString\u003e,\n    pub prompt: Option\u003cString\u003e,\n    pub max_retries: usize,\n    pub goal_gate: bool,\n    pub retry_target: Option\u003cString\u003e,\n    pub fallback_retry_target: Option\u003cString\u003e,\n    pub fidelity: Option\u003cString\u003e,\n    pub thread_id: Option\u003cString\u003e,\n    pub classes: Vec\u003cString\u003e,\n    pub timeout: Option\u003cDuration\u003e,\n    pub llm_model: Option\u003cString\u003e,\n    pub llm_provider: Option\u003cString\u003e,\n    pub reasoning_effort: Option\u003cString\u003e,\n    pub auto_status: bool,\n    pub allow_partial: bool,\n    pub raw_attrs: HashMap\u003cString, AttributeValue\u003e,\n}\n\npub struct PipelineEdge {\n    pub from: String,\n    pub to: String,\n    pub label: Option\u003cString\u003e,\n    pub condition: Option\u003cString\u003e,\n    pub weight: i32,\n    pub fidelity: Option\u003cString\u003e,\n    pub thread_id: Option\u003cString\u003e,\n    pub loop_restart: bool,\n}\n```\n\n## Resolution steps\n1. Flatten subgraphs: merge subgraph node defaults into contained nodes\n2. Apply graph-level node defaults\n3. Expand chained edges into individual edges\n4. Derive classes from subgraph labels\n5. Type all node attributes (shape, prompt, max_retries, etc.)\n6. Build adjacency index for fast outgoing-edge lookup\n\n## Methods\n- from_dot(DotGraph) -\u003e Result\u003cPipelineGraph\u003e — resolution + basic structural validation\n- start_node() -\u003e \u0026PipelineNode — find Mdiamond or id=\"start\"/\"Start\"\n- exit_node() -\u003e \u0026PipelineNode — find Msquare\n- outgoing_edges(node_id) -\u003e \u0026[PipelineEdge]\n- node(id) -\u003e Option\u003c\u0026PipelineNode\u003e\n- all_nodes() -\u003e impl Iterator\n- all_edges() -\u003e impl Iterator\n\n## Acceptance criteria\n- from_dot correctly resolves all node defaults from subgraphs\n- Chained edges are expanded\n- start_node/exit_node find correct nodes\n- outgoing_edges returns edges in insertion order\n- All typed fields extracted (shape, prompt, max_retries, goal_gate, etc.)","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:16:40.014047-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:16:40.014047-08:00","dependencies":[{"issue_id":"attractor-rk2","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:54.296901-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-rk2","depends_on_id":"attractor-4ac","type":"blocks","created_at":"2026-02-10T14:26:55.259144-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-rk2","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:26:55.564861-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-sa0","title":"Scaffold Cargo workspace with 7 crates","description":"# Scaffold Cargo Workspace\n\n## What\nCreate the Cargo workspace root and all 7 crate directories with initial Cargo.toml files,\nestablishing the dependency graph between crates.\n\n## Why\nEvery other task depends on the workspace existing. This is the foundation.\n\n## Details\n\n### Workspace root Cargo.toml\n```toml\n[workspace]\nresolver = \"2\"\nmembers = [\n    \"crates/attractor-types\",\n    \"crates/attractor-dot\",\n    \"crates/attractor-llm\",\n    \"crates/attractor-tools\",\n    \"crates/attractor-agent\",\n    \"crates/attractor-pipeline\",\n    \"crates/attractor-cli\",\n]\n\n[workspace.dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\nthiserror = \"2\"\ntracing = \"0.1\"\nuuid = { version = \"1\", features = [\"v4\"] }\n```\n\n### Crate dependency graph\n- attractor-types: no internal deps (foundation)\n- attractor-dot: depends on attractor-types\n- attractor-llm: depends on attractor-types\n- attractor-tools: depends on attractor-types\n- attractor-agent: depends on attractor-types, attractor-llm, attractor-tools\n- attractor-pipeline: depends on attractor-types, attractor-dot, attractor-llm, attractor-tools, attractor-agent\n- attractor-cli: depends on all crates\n\n### Each crate gets\n- Cargo.toml with correct dependencies\n- src/lib.rs (or src/main.rs for cli) with module stubs\n- Initial doc comment explaining the crate's purpose\n\n### Acceptance criteria\n- `cargo check --workspace` compiles with no errors\n- Each crate has a placeholder test that passes\n- `cargo test --workspace` passes","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:15:04.199043-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:15:04.199043-08:00"}
{"id":"attractor-sq9","title":"Implement system prompt builder with project doc discovery","description":"# System Prompt Builder (attractor-agent)\n\n## What\nAssemble the layered system prompt per agent-loop spec Section 6.\n\n## Layers (in order, later takes precedence)\n1. Provider-specific base instructions (from ProviderProfile)\n2. Environment context (platform, git, working dir, date, model info)\n3. Tool descriptions (from active profile)\n4. Project-specific instructions (AGENTS.md, CLAUDE.md, etc.)\n5. User instruction overrides (appended last)\n\n## Environment context block\n\\`\\`\\`\n\u003cenvironment\u003e\nWorking directory: {working_directory}\nIs git repository: {true/false}\nGit branch: {current_branch}\nPlatform: {darwin/linux/windows}\nOS version: {os_version_string}\nToday date: {YYYY-MM-DD}\nModel: {model_display_name}\n\u003c/environment\u003e\n\\`\\`\\`\n\n## Project doc discovery (spec Section 6.5)\nWalk from git root to cwd. Recognized files:\n- AGENTS.md (universal, always loaded)\n- CLAUDE.md (Anthropic profile)\n- GEMINI.md (Gemini profile)\n- .codex/instructions.md (OpenAI profile)\n\nLoading rules:\n- Root-level first, subdirectory files appended (deeper = higher precedence)\n- Total budget: 32KB\n- Only load files matching active provider\n\n## Acceptance criteria\n- All 5 layers present in correct order\n- Environment context includes platform, git info, date\n- Project docs discovered and loaded respecting provider\n- 32KB budget enforced with truncation marker","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:19:31.656973-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:19:31.656973-08:00","dependencies":[{"issue_id":"attractor-sq9","depends_on_id":"attractor-mq9","type":"blocks","created_at":"2026-02-10T14:27:02.447243-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-tea","title":"Implement Anthropic provider adapter (Messages API)","description":"# Anthropic Provider Adapter (attractor-llm)\n\n## What\nImplement the Anthropic adapter using their native Messages API (/v1/messages).\nThis is the highest-priority provider since we're building primarily with Claude.\n\n## Why native API (not OpenAI compat)\nPer spec Section 2.7: \"Each provider adapter MUST use the provider's native, preferred API.\"\nThe Messages API supports extended thinking, prompt caching (cache_control), and the\nstrict user/assistant alternation model. OpenAI-compatible endpoints miss these.\n\n## Request translation\nUnified Request → Anthropic JSON:\n- system messages extracted to top-level \"system\" parameter\n- ContentPart::Text → {\"type\": \"text\", \"text\": \"...\"}\n- ContentPart::ToolCall → {\"type\": \"tool_use\", \"id\": \"...\", \"name\": \"...\", \"input\": {...}}\n- ContentPart::ToolResult → {\"type\": \"tool_result\", \"tool_use_id\": \"...\", \"content\": \"...\"}\n- ContentPart::Thinking → {\"type\": \"thinking\", \"thinking\": \"...\"}\n- ContentPart::RedactedThinking → round-trip verbatim (opaque)\n- tools → Anthropic tool schema format\n- reasoning_effort → maps to thinking budget in extended thinking\n\n## Response translation\nAnthropic JSON → Unified Response:\n- content blocks: text → ContentPart::Text, tool_use → ContentPart::ToolCall\n- thinking blocks → ContentPart::Thinking\n- usage: input_tokens, output_tokens, cache_creation_input_tokens, cache_read_input_tokens\n\n## CRITICAL: Prompt caching (spec Section 2.10)\nAnthropic requires EXPLICIT cache_control annotations — caching is NOT automatic.\nFor agentic workloads, the adapter must auto-inject cache_control breakpoints:\n- On the system prompt (always cache the system prompt)\n- On the last user message before the most recent assistant response\nThis reduces input token costs by ~90% for multi-turn conversations.\n\n```rust\n// When building Anthropic request body:\nfn inject_cache_breakpoints(messages: \u0026mut Vec\u003cAnthropicMessage\u003e) {\n    // Find the system message and add cache_control\n    // Find the last user message and add cache_control to its last content block\n}\n```\n\n## Beta headers\nPass via provider_options:\n- interleaved-thinking-2025-05-14\n- token-efficient-tools-2025-02-19\n- prompt-caching-2024-07-31\n\n## Streaming\nAnthropic SSE events:\n- message_start → MessageStart\n- content_block_start → ToolCallStart (for tool_use type)\n- content_block_delta → ContentDelta or ToolCallDelta\n- message_delta → extract finish_reason, usage\n- message_stop → MessageEnd\n\n## Acceptance criteria\n- complete() sends correct JSON to /v1/messages and parses response\n- stream() parses Anthropic SSE events into StreamEvent stream\n- System messages extracted to top-level parameter\n- cache_control auto-injected for agentic workloads\n- Beta headers passed correctly\n- Extended thinking blocks round-trip correctly\n- Token usage includes cache_read_tokens and cache_write_tokens\n- Error responses mapped to AttractorError variants (429→RateLimited, 401→AuthError, etc.)","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:16:53.473932-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:16:53.473932-08:00","dependencies":[{"issue_id":"attractor-tea","depends_on_id":"attractor-3zy","type":"blocks","created_at":"2026-02-10T14:26:56.896159-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-vsf","title":"Implement Tool trait, ToolRegistry, and ExecutionEnvironment","description":"# Tool System Foundation (attractor-tools)\n\n## What\nDefine the core abstractions for tool execution: the Tool trait that all built-in\ntools implement, the ToolRegistry that manages them, and the ExecutionEnvironment\nthat abstracts where tools run.\n\n## Tool trait (agent-loop spec Section 3.8)\n```rust\npub trait Tool: Send + Sync {\n    fn definition(\u0026self) -\u003e ToolDefinition;\n    async fn execute(\n        \u0026self,\n        arguments: serde_json::Value,\n        env: \u0026dyn ExecutionEnvironment,\n    ) -\u003e Result\u003cString, AttractorError\u003e;\n}\n```\n\n## ToolRegistry\n```rust\npub struct ToolRegistry {\n    tools: HashMap\u003cString, Box\u003cdyn Tool\u003e\u003e,\n}\nimpl ToolRegistry {\n    pub fn register(\u0026mut self, tool: impl Tool + 'static);\n    pub fn unregister(\u0026mut self, name: \u0026str);\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026dyn Tool\u003e;\n    pub fn definitions(\u0026self) -\u003e Vec\u003cToolDefinition\u003e;\n    pub fn names(\u0026self) -\u003e Vec\u003cString\u003e;\n}\n```\n\n## ExecutionEnvironment (agent-loop spec Section 4.1)\n```rust\npub trait ExecutionEnvironment: Send + Sync {\n    async fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, AttractorError\u003e;\n    async fn write_file(\u0026self, path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), AttractorError\u003e;\n    async fn file_exists(\u0026self, path: \u0026Path) -\u003e Result\u003cbool, AttractorError\u003e;\n    async fn list_directory(\u0026self, path: \u0026Path, depth: usize) -\u003e Result\u003cVec\u003cDirEntry\u003e, AttractorError\u003e;\n    async fn exec_command(\u0026self, command: \u0026str, timeout_ms: u64, cwd: Option\u003c\u0026Path\u003e,\n                          env_vars: Option\u003c\u0026HashMap\u003cString, String\u003e\u003e) -\u003e Result\u003cExecResult, AttractorError\u003e;\n    async fn grep(\u0026self, pattern: \u0026str, path: \u0026Path, options: \u0026GrepOptions) -\u003e Result\u003cString, AttractorError\u003e;\n    async fn glob_files(\u0026self, pattern: \u0026str, base: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e, AttractorError\u003e;\n    fn working_directory(\u0026self) -\u003e \u0026Path;\n    fn platform(\u0026self) -\u003e \u0026str;\n}\n\npub struct ExecResult {\n    pub stdout: String,\n    pub stderr: String,\n    pub exit_code: i32,\n    pub timed_out: bool,\n    pub duration_ms: u64,\n}\n```\n\n## Tool execution pipeline (spec Section 3.8)\n1. LOOKUP — find RegisteredTool by name\n2. VALIDATE — parse arguments against JSON Schema\n3. EXECUTE — call tool with execution environment\n4. TRUNCATE — apply output size limits\n5. EMIT — emit event with full output\n6. RETURN — return truncated output as ToolResult\n\n## Acceptance criteria\n- Tool trait is object-safe (can be stored as Box\u003cdyn Tool\u003e)\n- ToolRegistry supports register, unregister, get, list\n- ExecutionEnvironment is object-safe\n- Tool execution pipeline validates arguments before execution\n- Missing tool returns error (not panic)","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:17:52.414474-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:17:52.414474-08:00","dependencies":[{"issue_id":"attractor-vsf","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:26:58.523493-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-vsf","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:58.836679-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-wfp","title":"Implement Outcome, StageStatus, and Checkpoint types","description":"# Outcome, StageStatus, and Checkpoint (attractor-types)\n\n## What\nImplement the core execution result types that drive the pipeline engine's routing,\nretry, and crash recovery logic.\n\n## Why\n- Outcome is what every node handler returns — it determines which edge to follow\n- StageStatus drives the edge selection algorithm and goal gate enforcement\n- Checkpoint enables crash recovery and resume-from-last-good-state\n\n## Outcome (spec Section 5.2)\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Outcome {\n    pub status: StageStatus,\n    pub preferred_label: Option\u003cString\u003e,\n    pub suggested_next_ids: Vec\u003cString\u003e,\n    pub context_updates: HashMap\u003cString, serde_json::Value\u003e,\n    pub notes: String,\n    pub failure_reason: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum StageStatus {\n    Success,\n    PartialSuccess,\n    Retry,\n    Fail,\n    Skipped,\n}\n```\n\nKey: StageStatus must serialize to lowercase strings matching the condition expression\nvalues (\"success\", \"fail\", etc.) since edge conditions compare against these.\n\n## Checkpoint (spec Section 5.3)\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Checkpoint {\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    pub current_node: String,\n    pub completed_nodes: Vec\u003cString\u003e,\n    pub node_retries: HashMap\u003cString, usize\u003e,\n    pub context_values: HashMap\u003cString, serde_json::Value\u003e,\n    pub logs: Vec\u003cString\u003e,\n}\n```\n\nMethods: save(path) and load(path) for JSON serialization to/from filesystem.\n\n## Resume behavior (spec Section 5.3)\nWhen loading a checkpoint:\n1. Restore context from context_values\n2. Skip completed_nodes\n3. Restore retry counters\n4. Next node = the one after current_node\n5. If previous node used full fidelity, degrade to summary:high for first resumed node\n\n## Acceptance criteria\n- Outcome serializes to JSON matching the status.json contract (Appendix C)\n- StageStatus round-trips through serde correctly\n- Checkpoint save/load produces identical data\n- Checkpoint file format matches spec example","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:15:55.850772-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:15:55.850772-08:00","dependencies":[{"issue_id":"attractor-wfp","depends_on_id":"attractor-sa0","type":"blocks","created_at":"2026-02-10T14:26:53.630427-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-wfp","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:26:54.939034-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-wz2","title":"Implement HandlerRegistry with shape-to-type mapping","description":"# Handler Registry (attractor-pipeline)\n\n## What\nImplement the handler dispatch system that maps node shapes/types to handler\nimplementations, per attractor-spec.md Sections 4.1-4.2.\n\n## Handler trait\n```rust\npub trait NodeHandler: Send + Sync {\n    fn handler_type(\u0026self) -\u003e \u0026str;\n    async fn execute(\n        \u0026self,\n        node: \u0026PipelineNode,\n        context: \u0026Context,\n        graph: \u0026PipelineGraph,\n        logs_root: \u0026Path,\n    ) -\u003e Result\u003cOutcome, AttractorError\u003e;\n}\n```\n\nNote: Needs DynHandler wrapper for object safety (same pattern as DynProvider).\n\n## HandlerRegistry\n```rust\npub struct HandlerRegistry {\n    handlers: HashMap\u003cString, DynHandler\u003e,\n    default_handler: DynHandler,\n}\n```\n\n## Resolution order (spec Section 4.2)\n1. Explicit type attribute on node (e.g., type=\"wait.human\")\n2. Shape-based mapping (see table below)\n3. Default handler (codergen/LLM handler)\n\n## Shape-to-handler-type mapping (spec Section 2.8)\n| Shape | Handler Type | Description |\n|-------|-------------|-------------|\n| Mdiamond | start | Pipeline entry point |\n| Msquare | exit | Pipeline exit point |\n| box | codergen | LLM task (default for all nodes) |\n| hexagon | wait.human | Human gate |\n| diamond | conditional | Conditional routing |\n| component | parallel | Parallel fan-out |\n| tripleoctagon | parallel.fan_in | Parallel fan-in |\n| parallelogram | tool | External tool execution |\n| house | stack.manager_loop | Supervisor loop |\n\n## Custom handler registration\nregistry.register(\"my_custom_type\", MyHandler::new()) — replaces existing if same type\n\n## Acceptance criteria\n- Resolution follows 3-step priority correctly\n- All 9 shape mappings work\n- Custom handlers registered by type string\n- Unknown type falls back to default (codergen)\n- Handler contract: stateless, panics caught and converted to FAIL outcomes","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:23:02.587236-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:23:02.587236-08:00","dependencies":[{"issue_id":"attractor-wz2","depends_on_id":"attractor-rk2","type":"blocks","created_at":"2026-02-10T14:27:03.147094-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-wz2","depends_on_id":"attractor-mxw","type":"blocks","created_at":"2026-02-10T14:27:03.458835-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-xl0","title":"Implement loop detection and steering injection","description":"# Loop Detection (attractor-agent)\n\n## What\nDetect when the agent falls into a repeating pattern of tool calls and inject a\nwarning to break the cycle. Per agent-loop spec Section 2.10.\n\n## Algorithm\nTrack signature of each tool call (name + arguments hash). If the last N calls\n(default: 10) contain a repeating pattern of length 1, 2, or 3, inject a warning.\n\n\\`\\`\\`rust\nfn detect_loop(history: \u0026[Turn], window_size: usize) -\u003e bool {\n    let recent = extract_tool_call_signatures(history, window_size);\n    if recent.len() \u003c window_size { return false; }\n\n    for pattern_len in [1, 2, 3] {\n        if window_size % pattern_len != 0 { continue; }\n        let pattern = \u0026recent[..pattern_len];\n        let all_match = (pattern_len..window_size)\n            .step_by(pattern_len)\n            .all(|i| \u0026recent[i..i+pattern_len] == pattern);\n        if all_match { return true; }\n    }\n    false\n}\n\\`\\`\\`\n\nWarning message injected as SteeringTurn:\n\"Loop detected: the last N tool calls follow a repeating pattern. Try a different approach.\"\n\n## Acceptance criteria\n- Detects repeating patterns of length 1 (same call 10 times)\n- Detects repeating patterns of length 2 (A,B,A,B,A,B...)\n- Detects repeating patterns of length 3 (A,B,C,A,B,C...)\n- Warning injected as SteeringTurn\n- Configurable window size\n- Does not false-positive on similar but different calls","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:19:10.37972-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:19:10.37972-08:00","dependencies":[{"issue_id":"attractor-xl0","depends_on_id":"attractor-mq9","type":"blocks","created_at":"2026-02-10T14:27:01.738597-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-yov","title":"Implement checkpoint save/restore and crash recovery","description":"# Checkpoint \u0026 Resume (attractor-pipeline)\n\n## What\nImplement the checkpoint system from attractor-spec.md Section 5.3 for crash recovery.\n\n## Save\nAfter each node completes, serialize checkpoint to {logs_root}/checkpoint.json:\n```json\n{\n    \"timestamp\": \"2026-02-10T...\",\n    \"current_node\": \"implement\",\n    \"completed_nodes\": [\"start\", \"plan\", \"implement\"],\n    \"node_retries\": {\"implement\": 1},\n    \"context\": { \"graph.goal\": \"...\", \"outcome\": \"success\" },\n    \"logs\": [\"Started plan\", \"Plan completed\", ...]\n}\n```\n\n## Restore\n1. Load checkpoint from {logs_root}/checkpoint.json\n2. Restore context from context_values\n3. Restore completed_nodes to skip finished work\n4. Restore retry counters\n5. Determine next node (one after current_node)\n6. If previous node used full fidelity → degrade to summary:high for first resumed node\n\n## Integration with execution engine\n- Engine calls save_checkpoint() after each node\n- Engine can be started with resume_from(checkpoint_path) to continue from last state\n- Checkpoint includes enough state to reconstruct execution position\n\n## Acceptance criteria\n- Checkpoint saved after each node completion\n- Checkpoint file is valid JSON and matches spec format\n- Resume from checkpoint produces same result as uninterrupted run\n- Completed nodes are skipped on resume\n- Retry counters preserved across resume\n- Fidelity degradation applied on first resumed node","status":"open","priority":2,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:25:56.455572-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:25:56.455572-08:00","dependencies":[{"issue_id":"attractor-yov","depends_on_id":"attractor-8yo","type":"blocks","created_at":"2026-02-10T14:27:11.843884-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-yov","depends_on_id":"attractor-wfp","type":"blocks","created_at":"2026-02-10T14:27:12.205695-08:00","created_by":"Scott Nixon"}]}
{"id":"attractor-zh7","title":"Implement condition expression language (=, !=, \u0026\u0026)","description":"# Condition Expression Language (attractor-pipeline)\n\n## What\nImplement the minimal boolean expression language used in edge conditions,\nper attractor-spec.md Section 10.\n\n## Grammar (spec Section 10.2)\n```\nConditionExpr  ::= Clause ( '\u0026\u0026' Clause )*\nClause         ::= Key Operator Literal\nKey            ::= 'outcome' | 'preferred_label' | 'context.' Path\nOperator       ::= '=' | '!='\nLiteral        ::= String | Integer | Boolean\n```\n\n## Semantics\n- Clauses are AND-combined, left to right\n- outcome → current node's outcome status (success, fail, etc.)\n- preferred_label → outcome's preferred_label\n- context.* → look up in run context (missing = empty string)\n- String comparison is exact, case-sensitive\n- ALL clauses must be true for condition to pass\n\n## Variable resolution (spec Section 10.4)\n```rust\nfn resolve_key(key: \u0026str, outcome: \u0026Outcome, context: \u0026Context) -\u003e String {\n    match key {\n        \"outcome\" =\u003e outcome.status.to_string(),\n        \"preferred_label\" =\u003e outcome.preferred_label.clone().unwrap_or_default(),\n        k if k.starts_with(\"context.\") =\u003e {\n            let ctx_key = \u0026k[\"context.\".len()..];\n            context.get_string(k, \"\")\n                .or_else(|| context.get_string(ctx_key, \"\"))\n        }\n        k =\u003e context.get_string(k, \"\").unwrap_or_default(),\n    }\n}\n```\n\n## Examples\n```\noutcome=success                              → true if node succeeded\noutcome=fail                                 → true if node failed\noutcome=success \u0026\u0026 context.tests_passed=true → compound condition\ncontext.loop_state!=exhausted                → not-equals\npreferred_label=Fix                          → match on preferred label\n```\n\n## Acceptance criteria\n- = operator works for string comparison\n- != operator works\n- \u0026\u0026 conjunction with multiple clauses\n- outcome variable resolves correctly\n- preferred_label variable resolves correctly\n- context.* variables resolve (missing = empty string)\n- Empty condition always true\n- Parse errors produce clear diagnostics","status":"open","priority":1,"issue_type":"task","owner":"citadelgrad@gmail.com","created_at":"2026-02-10T14:24:03.146651-08:00","created_by":"Scott Nixon","updated_at":"2026-02-10T14:24:03.146651-08:00","dependencies":[{"issue_id":"attractor-zh7","depends_on_id":"attractor-28l","type":"blocks","created_at":"2026-02-10T14:27:04.791838-08:00","created_by":"Scott Nixon"},{"issue_id":"attractor-zh7","depends_on_id":"attractor-wfp","type":"blocks","created_at":"2026-02-10T14:27:05.14391-08:00","created_by":"Scott Nixon"}]}
